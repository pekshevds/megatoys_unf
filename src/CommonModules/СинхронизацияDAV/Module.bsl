////////////////////////////////////////////////////////////////////////////////
//	Общие серверные процедуры для синхронизации с сервисами DAV
//
////////////////////////////////////////////////////////////////////////////////

#Область СлужебныйПрограммныйИнтерфейс

Процедура ПриЗаполненииРазрешенийНаДоступКВнешнимРесурсам(ЗапросыРазрешений) Экспорт
	
	НовыеРазрешения = Новый Массив;
	
	Разрешение = РаботаВБезопасномРежиме.РазрешениеНаИспользованиеИнтернетРесурса(
		"HTTPS",
		"caldav.icloud.com",
		443,
		НСтр("ru = 'iCloud CalDAV API (https://caldav.icloud.com)'"));
	НовыеРазрешения.Добавить(Разрешение);
	
	Разрешение = РаботаВБезопасномРежиме.РазрешениеНаИспользованиеИнтернетРесурса(
		"HTTPS",
		"caldav.yandex.ru",
		443,
		НСтр("ru = 'Yandex CalDAV API (https://caldav.yandex.ru)'"));
	НовыеРазрешения.Добавить(Разрешение);
	
	Разрешение = РаботаВБезопасномРежиме.РазрешениеНаИспользованиеИнтернетРесурса(
		"HTTPS",
		"calendar.mail.ru",
		443,
		НСтр("ru = 'MailRu CalDAV API (https://calendar.mail.ru)'"));
	НовыеРазрешения.Добавить(Разрешение);
	
	ЗапросыРазрешений.Добавить(РаботаВБезопасномРежиме.ЗапросНаИспользованиеВнешнихРесурсов(НовыеРазрешения));
	
КонецПроцедуры

// Выгрузка данных событий календаря сотрудника во внешний календарь за период
// 
// Параметры:
//  ОписаниеКалендаря - Структура - Описание календаря сотрудника включая список событий по которым зафиксированы изменения
//
Процедура ВыгрузитьДанныеКалендаря(ОписаниеКалендаря) Экспорт
	
	ДанныеАвторизации = Справочники.УчетныеЗаписиВнешнихКалендарей.ДанныеАвторизации(ОписаниеКалендаря.УчетнаяЗаписьВнешнегоКалендаря);
	Если Не ЗначениеЗаполнено(ДанныеАвторизации) Тогда
		Возврат;
	КонецЕсли;
	
	// ЗаписьСообщения используется только для управления нумерацией сообщений и блокировки узла.
	ЗаписьСообщения = ПланыОбмена.СоздатьЗаписьСообщения();
	ЗаписьXML = Новый ЗаписьXML;
	ЗаписьXML.УстановитьСтроку();
	ЗаписьСообщения.НачатьЗапись(ЗаписьXML, ОписаниеКалендаря.Узел);
	
	СтруктураURI = СтруктураURIСервераCalDAV(ДанныеАвторизации.КаталогКалендарей + ОписаниеКалендаря.Идентификатор);
	СтруктураURI.Логин = ДанныеАвторизации.Логин;
	СтруктураURI.Пароль = ДанныеАвторизации.Пароль;
	
	УстановитьПривилегированныйРежим(Истина);
	Соединение = HTTPСоединениеСервераCalDAV(СтруктураURI);
	ВыгруженныеСсылки = Новый Массив;
	Для Каждого Событие Из ОписаниеКалендаря.События Цикл
		КодСостояния = 0;
		Допустимо404 = Ложь;
		Если Событие.ТипОбъекта = "Событие" ИЛИ Событие.ТипОбъекта = "Задача" Тогда
			Если Событие.ПометкаУдаления Тогда
				Если ЗначениеЗаполнено(Событие.Идентификатор) Тогда
					Ответ = ВызватьМетод("DELETE", Соединение, ПутьИзИдентификаторов(СтруктураURI.ПутьНаСервере, Событие.Идентификатор));
					КодСостояния = Ответ.КодСостояния;
					Допустимо404 = Истина;
					
					МенеджерЗаписи = РегистрыСведений.ДанныеСобытийВнешнихКалендарей.СоздатьМенеджерЗаписи();
					МенеджерЗаписи.Источник	= Событие.Ссылка;
					МенеджерЗаписи.Прочитать();
					Если МенеджерЗаписи.Выбран() Тогда
						МенеджерЗаписи.Удалить();
					КонецЕсли;
				КонецЕсли;
			Иначе
				Если Не ЗначениеЗаполнено(Событие.Идентификатор) Тогда
					Событие.Идентификатор = Событие.Ссылка.УникальныйИдентификатор();
				КонецЕсли;
				Если ЗначениеЗаполнено(Событие.ОтпечатокОбъекта) Тогда
					Массив = Новый Массив;
					Массив.Добавить(Событие);
					Ответ = ВызватьМетод("PUT", Соединение, ПутьИзИдентификаторов(СтруктураURI.ПутьНаСервере, Событие.Идентификатор),
							РаботаСICalendar.СобытияiCalendar(Массив),, Событие.ОтпечатокОбъекта);
					КодСостояния = Ответ.КодСостояния;
					НовыйОтпечатокОбъекта = Неопределено;
					Если ЗначениеЗаполнено(Ответ.Заголовки["Etag"]) Тогда
						НовыйОтпечатокОбъекта = Ответ.Заголовки["Etag"];
					ИначеЕсли ЗначениеЗаполнено(Ответ.Заголовки["etag"]) Тогда
						НовыйОтпечатокОбъекта = Ответ.Заголовки["etag"];
					КонецЕсли;
					
					Если ЗначениеЗаполнено(НовыйОтпечатокОбъекта) Тогда
						МенеджерЗаписи = РегистрыСведений.ДанныеСобытийВнешнихКалендарей.СоздатьМенеджерЗаписи();
						МенеджерЗаписи.Источник	= Событие.Ссылка;
						МенеджерЗаписи.Прочитать();
						Если МенеджерЗаписи.Выбран() И МенеджерЗаписи.ОтпечатокОбъекта <> НовыйОтпечатокОбъекта Тогда
							МенеджерЗаписи.ОтпечатокОбъекта = НовыйОтпечатокОбъекта;
							МенеджерЗаписи.Записать();
						КонецЕсли;
					КонецЕсли;
				Иначе
					Массив = Новый Массив;
					Массив.Добавить(Событие);
					Ответ = ВызватьМетод("PUT", Соединение, ПутьИзИдентификаторов(СтруктураURI.ПутьНаСервере, Событие.Идентификатор),
							РаботаСICalendar.СобытияiCalendar(Массив));
					КодСостояния = Ответ.КодСостояния;
					
					МенеджерЗаписи = РегистрыСведений.ДанныеСобытийВнешнихКалендарей.СоздатьМенеджерЗаписи();
					МенеджерЗаписи.Источник	= Событие.Ссылка;
					МенеджерЗаписи.Прочитать();
					МенеджерЗаписи.ОтпечатокОбъекта	= ?(ЗначениеЗаполнено(Ответ.Заголовки["Etag"]), Ответ.Заголовки["Etag"], "");
					МенеджерЗаписи.Записать();
				КонецЕсли;
			КонецЕсли;
		Иначе
			ТелоЗапросаНаИзменениеКалендаря = ТелоЗапросаНаИзменениеНаименованияВнешнегоКалендаря(ОписаниеКалендаря.Наименование);
			Ответ = ВызватьМетод("PROPPATCH", Соединение, СтруктураURI.ПутьНаСервере, ТелоЗапросаНаИзменениеКалендаря);
			КодСостояния = Ответ.КодСостояния;
		КонецЕсли;
		
		Если КодСостояния >= 300
			И (КодСостояния <> 404 Или Не Допустимо404)
			И КодСостояния <> 412 Тогда // 412 Precondition Failed - запись изменили во внешнем календаре.
			
			ОписаниеОшибки = ПолучитьОписаниеОшибокHTTPВызова(СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				НСтр("ru = 'Не удалось выгрузить событие %1 от %2'"), Событие.Описание,	Событие.ДатаНачала), Ответ);
			ЗарегистрироватьОшибку(ОписаниеОшибки.КраткийТекстОшибки, ОписаниеОшибки.ПодробныйТекстОшибки);
			ВызватьИсключение ОписаниеОшибки.КраткийТекстОшибки;
			
		КонецЕсли;
		ВыгруженныеСсылки.Добавить(Событие.Ссылка);
	КонецЦикла;
	
	ПланыОбмена.ВыбратьИзменения(ОписаниеКалендаря.Узел, ЗаписьСообщения.НомерСообщения, ВыгруженныеСсылки);
	НомерСообщения = ЗаписьСообщения.НомерСообщения;
	ЗаписьСообщения.ЗакончитьЗапись();
	
	ПланыОбмена.УдалитьРегистрациюИзменений(ОписаниеКалендаря.Узел, НомерСообщения);
	
КонецПроцедуры

// Получение структуры с данными по подключению к внешнему сервису
// 
// Параметры:
//  СтрокаURI - Строка - адрес к внешнему ресурсу
// 
// Возвращаемое значение:
//  Структура - данными по подключению к внешнему сервису (хост, порт, имя сервера, логин, пароль)
//
Функция СтруктураURI(Знач СтрокаURI) Экспорт
	
	СтрокаURI = СокрЛП(СтрокаURI);
	
	// схема
	Схема = "";
	Позиция = СтрНайти(СтрокаURI, "://");
	Если Позиция > 0 Тогда
		Схема = НРег(Лев(СтрокаURI, Позиция - 1));
		СтрокаURI = Сред(СтрокаURI, Позиция + 3);
	КонецЕсли;
	
	// Строка соединения и путь на сервере.
	СтрокаСоединения = СтрокаURI;
	ПутьНаСервере = "";
	Позиция = СтрНайти(СтрокаСоединения, "/");
	Если Позиция > 0 Тогда
		ПутьНаСервере = Сред(СтрокаСоединения, Позиция + 1);
		СтрокаСоединения = Лев(СтрокаСоединения, Позиция - 1);
	КонецЕсли;
	
	// Информация пользователя и имя сервера.
	СтрокаАвторизации = "";
	ИмяСервера = СтрокаСоединения;
	Позиция = СтрНайти(СтрокаСоединения, "@", НаправлениеПоиска.СКонца);
	Если Позиция > 0 Тогда
		СтрокаАвторизации = Лев(СтрокаСоединения, Позиция - 1);
		ИмяСервера = Сред(СтрокаСоединения, Позиция + 1);
	КонецЕсли;
	
	// логин и пароль
	Логин = СтрокаАвторизации;
	Пароль = "";
	Позиция = СтрНайти(СтрокаАвторизации, ":");
	Если Позиция > 0 Тогда
		Логин = Лев(СтрокаАвторизации, Позиция - 1);
		Пароль = Сред(СтрокаАвторизации, Позиция + 1);
	КонецЕсли;
	
	// хост и порт
	Хост = ИмяСервера;
	Порт = "";
	Позиция = СтрНайти(ИмяСервера, ":");
	Если Позиция > 0 Тогда
		Хост = Лев(ИмяСервера, Позиция - 1);
		Порт = Сред(ИмяСервера, Позиция + 1);
		Если Не ТолькоЦифрыВСтроке(Порт) Тогда
			Порт = "";
		КонецЕсли;
	КонецЕсли;
	
	Результат = Новый Структура;
	Результат.Вставить("Схема", Схема);
	Результат.Вставить("Логин", Логин);
	Результат.Вставить("Пароль", Пароль);
	Результат.Вставить("ИмяСервера", ИмяСервера);
	Результат.Вставить("Хост", Хост);
	Результат.Вставить("Порт", ?(ПустаяСтрока(Порт), Неопределено, Число(Порт)));
	Результат.Вставить("ПутьНаСервере", ПутьНаСервере);
	Результат.Вставить("КорневойКаталог", "");
	Результат.Вставить("КаталогКалендарей", "");
	
	Возврат Результат;
	
КонецФункции 

// Получение адреса к каталогу календарей внешнего сервиса
//  Адрес к календарю внешнего сервиса используется в дальнейшем для получения списка календарей внешнего сервиса
// 
// Параметры:
//  ДанныеАвторизации - Структура - данные авторизации для подключения к внешнему ресурсу (логин, пароль, сервер, адрес корневого каталога)
// 
// Возвращаемое значение:
//  Структура - обновленные данные авторизации включая адрес каталога календарей внешнего сервиса
//  Число - статус ответа по запросу на получение адреса каталога календарей
//
Функция КаталогКалендарейНаСервереDAV(ДанныеАвторизации, СтатусОтвета = 0) Экспорт
	
	СтруктураURI = СтруктураURIСервераCalDAV(ДанныеАвторизации.Сервер);
	СтруктураURI.Логин = ДанныеАвторизации.Логин;
	СтруктураURI.Пароль = ДанныеАвторизации.Пароль;
	СтруктураURI.ПутьНаСервере = ДанныеАвторизации.КорневойКаталог;
	СтруктураURI.ПутьНаСервере = КорневойКаталогПользователяНаСервереDAV(ДанныеАвторизации, СтруктураURI); 
	
	Соединение = HTTPСоединениеСервераCalDAV(СтруктураURI);
	
	ТелоКакСтрока =
	"<propfind xmlns=""DAV:""
	|			xmlns:C=""urn:ietf:params:xml:ns:caldav"">
	|	<prop>
	|		<C:calendar-home-set/>
	|	</prop>
	|</propfind>";
	Ответ = ВызватьМетод("PROPFIND", Соединение, СтруктураURI.ПутьНаСервере, ТелоКакСтрока, 0);
	СтрокаXML = Ответ.ПолучитьТелоКакСтроку();
	СтатусОтвета = Ответ.КодСостояния;
	Если Ответ.КодСостояния = 207 Тогда
		ОтветXDTO = СтрокаXMLВXDTO(СтрокаXML);
		КаталогКалендарей = ОтветXDTO.response.propstat.prop.calendar_home_set.href;
		СтруктураURI = ОбщегоНазначенияКлиентСервер.СтруктураURI(КаталогКалендарей);
		Если Не ЗначениеЗаполнено(СтруктураURI.ИмяСервера) Тогда
			СтруктураURI = СтруктураURIСервераCalDAV(ДанныеАвторизации.Сервер);
			КаталогКалендарей = СтрШаблон("%1://%2:%3%4", СтруктураURI.Схема, СтруктураURI.Хост, СтруктураURI.Порт, КаталогКалендарей);
		КонецЕсли;
		Возврат КаталогКалендарей
	Иначе
		ОписаниеОшибки = ПолучитьОписаниеОшибокHTTPВызова(НСтр("ru = 'Получение каталога календарей ошибкой.'"), Ответ);
		ЗарегистрироватьОшибку(ОписаниеОшибки.КраткийТекстОшибки, ОписаниеОшибки.ПодробныйТекстОшибки);
		ВызватьИсключение ОписаниеОшибки.КраткийТекстОшибки;
	КонецЕсли;
	
КонецФункции

// Получение списка календарей внешнего сервиса
//  Список календарей используется в дальнейшем для получения данных о событиях внешнего календаря за период
// 
// Параметры:
//  ДанныеАвторизации - Структура - данные авторизации для подключения к внешнему ресурсу (логин, пароль, сервер, адрес корневого каталога и каталога календарей)
// 
// Возвращаемое значение:
//  Структура - список календарей включая идентификатор внешнего календаря, наименование и тип календаря (события или задачи)
//
Функция СписокКалендарейНаСервереDAV(ДанныеАвторизации) Экспорт
	
	СтруктураURI = СтруктураURIСервераCalDAV(ДанныеАвторизации.КаталогКалендарей);
	СтруктураURI.Логин = ДанныеАвторизации.Логин;
	СтруктураURI.Пароль = ДанныеАвторизации.Пароль;
	
	Соединение = HTTPСоединениеСервераCalDAV(СтруктураURI);
	
	ТелоКакСтрока =
	"<propfind xmlns=""DAV:"">
	|	<prop>
	|		<displayname/>
	|		<resourcetype/>
	|		<C:supported-calendar-component-set xmlns:C=""urn:ietf:params:xml:ns:caldav""/>
	|	</prop>
	|</propfind>";
	Ответ = ВызватьМетод("PROPFIND", Соединение, СтруктураURI.ПутьНаСервере, ТелоКакСтрока, 1);
	СтрокаXML = Ответ.ПолучитьТелоКакСтроку();
	СтатусОтвета = Ответ.КодСостояния;
	Если Не Ответ.КодСостояния = 207 Тогда
		ОписаниеОшибки = ПолучитьОписаниеОшибокHTTPВызова(НСтр("ru = 'Получение списка календарей завершилось ошибкой.'"), Ответ);
		ЗарегистрироватьОшибку(ОписаниеОшибки.КраткийТекстОшибки, ОписаниеОшибки.ПодробныйТекстОшибки);
		ВызватьИсключение ОписаниеОшибки.КраткийТекстОшибки;
	КонецЕсли;
	Попытка
		ОтветXDTO = СтрокаXMLВXDTO(СтрокаXML);
		СписокКалендарей = Новый ТаблицаЗначений;
		СписокКалендарей.Колонки.Добавить("Наименование", Новый ОписаниеТипов("Строка",,Новый КвалификаторыСтроки(255)));
		СписокКалендарей.Колонки.Добавить("Идентификатор", Новый ОписаниеТипов("Строка",,Новый КвалификаторыСтроки(255)));
		СписокКалендарей.Колонки.Добавить("ТипСервиса", Новый ОписаниеТипов("Строка",,Новый КвалификаторыСтроки(40)));
		СписокКалендарей.Колонки.Добавить("ТипКалендаря", Новый ОписаниеТипов("Строка",,Новый КвалификаторыСтроки(6)));
		Для каждого Элемент Из ОтветXDTO.response Цикл
			Если ТипЗнч(Элемент.propstat) = Тип("ОбъектXDTO") Тогда
				Если СтрНайти(Элемент.propstat.status, "200") > 0 Тогда
					Если Не Элемент.propstat.prop.resourcetype.Свойства().Получить("calendar") = Неопределено Тогда
						НоваяСтрока = СписокКалендарей.Добавить();
						НоваяСтрока["Наименование"] = Элемент.propstat.prop.displayname;
						НоваяСтрока["Идентификатор"] = ВыделитьИдентификатор(Элемент.href);
						НоваяСтрока["ТипСервиса"] = СтруктураURI.Хост;
						НоваяСтрока["ТипКалендаря"] = Элемент.propstat.prop.supported_calendar_component_set.comp.name;
					КонецЕсли;
				КонецЕсли;
			КонецЕсли;
		КонецЦикла;
	Исключение
		ЗарегистрироватьОшибку(КраткоеПредставлениеОшибки(ИнформацияОбОшибке()),
			ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
		ВызватьИсключение;
	КонецПопытки;
	Возврат СписокКалендарей;
	
КонецФункции

// Загрузка данных о измененных событиях внешнего календаря за период
// 
// Параметры:
//  ОписаниеКалендаря - Структура - Описание календаря сотрудника
//  ДатаНачала - Дата - дата начала периода поиска изменений
//  ДатаОкончания - Дата - дата окончания периода поиска изменений
//
Процедура ЗаполнитьСобытияКалендаря(ОписаниеКалендаря, ДатаНачала, ДатаОкончания) Экспорт
	
	ДанныеАвторизации = Справочники.УчетныеЗаписиВнешнихКалендарей.ДанныеАвторизации(ОписаниеКалендаря.УчетнаяЗаписьВнешнегоКалендаря);
	Если Не ЗначениеЗаполнено(ДанныеАвторизации) Тогда
		Возврат;
	КонецЕсли;
	
	СтруктураURI = СтруктураURIСервераCalDAV(СтрШаблон("%1%2/",ДанныеАвторизации.КаталогКалендарей, ОписаниеКалендаря.Идентификатор));
	СтруктураURI.Логин = ДанныеАвторизации.Логин;
	СтруктураURI.Пароль = ДанныеАвторизации.Пароль;
	
	УстановитьПривилегированныйРежим(Истина);
	Соединение = HTTPСоединениеСервераCalDAV(СтруктураURI);
	
	ДействительныйТокенСинхронизации = ДействительныйТокенСинхронизации(Соединение, СтруктураURI, ОписаниеКалендаря.ТокенСинхронизации);
	Если Не ЗначениеЗаполнено(ОписаниеКалендаря.ТокенСинхронизации) Тогда
		ЗаполнитьВсемиСобытиями(ОписаниеКалендаря, Соединение, СтруктураURI, ДатаНачала, ДатаОкончания);
		ОписаниеКалендаря.ТокенСинхронизации = ДействительныйТокенСинхронизации(Соединение, СтруктураURI, ОписаниеКалендаря.ТокенСинхронизации);
	ИначеЕсли Не ОписаниеКалендаря.ТокенСинхронизации = ДействительныйТокенСинхронизации Тогда
		ЗаполнитьИзмененными(ОписаниеКалендаря, Соединение, СтруктураURI, ДатаНачала, ДатаОкончания);
		ОписаниеКалендаря.ТокенСинхронизации = ДействительныйТокенСинхронизации(Соединение, СтруктураURI, ОписаниеКалендаря.ТокенСинхронизации);
	КонецЕсли;
	
	
КонецПроцедуры

// Загрузка данных о всех событиях внешнего календаря за период
// 
// Параметры:
//  ДанныеАвторизации - Структура - данные авторизации для подключения к внешнему ресурсу (логин, пароль, сервер, адрес корневого каталога и каталога календарей)
//  ОписаниеКалендаря - Структура - Описание календаря сотрудника
//  ДатаНачала - Дата - дата начала периода поиска изменений
//  ДатаОкончания - Дата - дата окончания периода поиска изменений
//
Процедура ЗагрузитьВсеСобытияКалендаряЗаПериод(ДанныеАвторизации, ОписаниеКалендаря, ДатаНачала, ДатаОкончания) Экспорт
	
	СтруктураURI = СтруктураURIСервераCalDAV(СтрШаблон("%1/%2%3",ДанныеАвторизации.Сервер, ДанныеАвторизации.КаталогКалендарей, ОписаниеКалендаря.Идентификатор));
	СтруктураURI.Логин = ДанныеАвторизации.Логин;
	СтруктураURI.Пароль = ДанныеАвторизации.Пароль;
	УстановитьПривилегированныйРежим(Истина);
	Соединение = HTTPСоединениеСервераCalDAV(СтруктураURI);
	ЗаполнитьВсемиСобытиями(ОписаниеКалендаря, Соединение, СтруктураURI, ДатаНачала, ДатаОкончания);
	
КонецПроцедуры

// Загрузка данных о событиях внешнего календаря по списку адресов
// 
// Параметры:
//  СписокСобытийДляПроверки - Массив - список адресов событий
//  ОписаниеКалендаря - Структура - Описание календаря сотрудника
//  ДанныеАвторизации - Структура - данные авторизации для подключения к внешнему ресурсу (логин, пароль, сервер, адрес корневого каталога)
//
Процедура ПолучитьДанныеПоСобытиям(СписокСобытийДляПроверки, ОписаниеКалендаря, ДанныеАвторизации) Экспорт
	
	СтрокаСсылок = "";
	Для каждого Событие Из СписокСобытийДляПроверки Цикл
		СтрокаСсылок = СтрокаСсылок + Символы.ПС + СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			"	<D:href>%1</D:href>", Событие);
	КонецЦикла;
	
	ТелоКакСтрока = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
	"<C:calendar-multiget xmlns:D=""DAV:""
	|					xmlns:C=""urn:ietf:params:xml:ns:caldav"">
	|	<D:prop>
	|		<D:getetag/>
	|		<C:calendar-data/>
	|	</D:prop>%1
	|</C:calendar-multiget>", СтрокаСсылок);
	
	Если Не ЗначениеЗаполнено(ТелоКакСтрока) Тогда
		Возврат;
	КонецЕсли;

	СтруктураURI = СтруктураURIСервераCalDAV(ДанныеАвторизации.КаталогКалендарей + ОписаниеКалендаря.Идентификатор);
	СтруктураURI.Логин = ДанныеАвторизации.Логин;
	СтруктураURI.Пароль = ДанныеАвторизации.Пароль;
	
	УстановитьПривилегированныйРежим(Истина);
	Соединение = HTTPСоединениеСервераCalDAV(СтруктураURI);
	
	Ответ = ВызватьМетод("REPORT", Соединение, СтруктураURI.ПутьНаСервере, ТелоКакСтрока, 1);
	Если Не Ответ.КодСостояния = 207 Тогда
		Возврат;
	КонецЕсли;
	События = ОписаниеКалендаря.События;
	События.Очистить();
	Соответствие = Новый Соответствие;
	Соответствие.Вставить("getetag", "ОтпечатокОбъекта");
	ОбработатьMultiStatusОтвет(Ответ, События, Соответствие, Истина);
	
КонецПроцедуры

// Получение наименования календаря внешнего сервиса
// 
// Параметры:
//  ДанныеАвторизации - Структура - данные авторизации для подключения к внешнему ресурсу (логин, пароль, сервер, адрес корневого каталога и каталога календарей)
//  ОписаниеКалендаря - Структура - Описание календаря сотрудника
// 
// Возвращаемое значение:
//  Строка - наименование календаря внешнего сервиса
//
Функция ПолучитьИмяКалендаряDAV(ДанныеАвторизации, ОписаниеКалендаря) Экспорт
	
	СтруктураURI = СтруктураURIСервераCalDAV(ДанныеАвторизации.КаталогКалендарей + ОписаниеКалендаря.Идентификатор);
	СтруктураURI.Логин = ДанныеАвторизации.Логин;
	СтруктураURI.Пароль = ДанныеАвторизации.Пароль;
	
	Соединение = HTTPСоединениеСервераCalDAV(СтруктураURI);
	
	ТелоКакСтрока =
	"<D:propfind xmlns:D=""DAV:"" xmlns:C=""http://calendarserver.org/ns/"">
	|	<D:prop>
	|		<D:displayname/>
	|	</D:prop>
	|</D:propfind>";
	Заголовки = Новый Соответствие;
	Заголовки.Вставить("Depth", 0);
	Заголовки.Вставить("Content-Type", "application/xml; charset=""utf-8""");
	Запрос = Новый HTTPЗапрос(СтруктураURI.ПутьНаСервере, Заголовки);
	Запрос.УстановитьТелоИзСтроки(ТелоКакСтрока, "utf-8");
	Попытка
		Ответ = Соединение.ВызватьHTTPМетод("PROPFIND", Запрос);
	Исключение
		ЗарегистрироватьОшибку(КраткоеПредставлениеОшибки(ИнформацияОбОшибке()),
			ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
		ВызватьИсключение;
	КонецПопытки;
	Если Ответ.КодСостояния = 207 Тогда
		ТаблицаОтвета = Новый ТаблицаЗначений;
		ТаблицаОтвета.Колонки.Добавить("displayname", Новый ОписаниеТипов("Строка"));
		ОбработатьMultiStatusОтвет(Ответ, ТаблицаОтвета);
		Если ЗначениеЗаполнено(ТаблицаОтвета) Тогда
			ИмяКалендаряDAV = ТаблицаОтвета[0].displayname;
		КонецЕсли;
	КонецЕсли;
	Возврат ИмяКалендаряDAV;
	
КонецФункции

// Создание календаря на стороне внешнего сервиса
// 
// Параметры:
//  ДанныеАвторизации - Структура - данные авторизации для подключения к внешнему ресурсу (логин, пароль, сервер, адрес корневого каталога)
//  ИмяКалендаря - Массив - список адресов событий
//  ОписаниеКалендаря - Строка - краткое описание календаря
//  КодКалендаря - Строка - идентификатор созданного внешнего календаря
//
Процедура СоздатьКалендарь(ДанныеАвторизации, ИмяКалендаря, ОписаниеКалендаря = "", КодКалендаря = "") Экспорт
	
	СтруктураURI = СтруктураURIСервераCalDAV(ДанныеАвторизации.КаталогКалендарей);
	СтруктураURI.Логин = ДанныеАвторизации.Логин;
	СтруктураURI.Пароль = ДанныеАвторизации.Пароль;
	
	СтруктураURI.ПутьНаСервере = СтрШаблон("%1%2%3", СтруктураURI.ПутьНаСервере, "events/", КодКалендаря);
	Соединение = HTTPСоединениеСервераCalDAV(СтруктураURI);
	
	ТелоКакСтрока = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
	"<C:mkcalendar xmlns:D=""DAV:"" xmlns:C=""urn:ietf:params:xml:ns:caldav"">
	|<D:set>
	|	<D:prop>
	|		<D:displayname>%1</D:displayname>
	|		<C:calendar-description xml:lang=""en"">%2</C:calendar-description>
	|		<C:supported-calendar-component-set>
	|			<C:comp name=""VEVENT""/>
	|		</C:supported-calendar-component-set>
	|	</D:prop>
	|</D:set>
	|</C:mkcalendar>",
	ИмяКалендаря, ОписаниеКалендаря);
	
	Ответ = ВызватьМетод("MKCALENDAR", Соединение, СтруктураURI.ПутьНаСервере, ТелоКакСтрока, 0);
		СтрокаXML = Ответ.ПолучитьТелоКакСтроку();
	СтатусОтвета = Ответ.КодСостояния;
	Если Не Ответ.КодСостояния = 201 Тогда
		ОписаниеОшибки = ПолучитьОписаниеОшибокHTTPВызова(НСтр("ru = 'Создание каталога внешнего календаря завершилось ошибкой.'"), Ответ);
		ЗарегистрироватьОшибку(ОписаниеОшибки.КраткийТекстОшибки, ОписаниеОшибки.ПодробныйТекстОшибки);
		ВызватьИсключение ОписаниеОшибки.КраткийТекстОшибки;
	КонецЕсли;
	
КонецПроцедуры

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

Функция КорневойКаталогПользователяНаСервереDAV(ДанныеАвторизации, СтруктураURI)
	
	Соединение = HTTPСоединениеСервераCalDAV(СтруктураURI);
	
	ТелоКакСтрока =
	"<propfind xmlns=""DAV:"">
	|	<prop>
	|		<current-user-principal/>
	|	</prop>
	|</propfind>";
	Ответ = ВызватьМетод("PROPFIND", Соединение, СтруктураURI.ПутьНаСервере, ТелоКакСтрока, 0);
		СтрокаXML = Ответ.ПолучитьТелоКакСтроку();
	СтатусОтвета = Ответ.КодСостояния;
	Если Не Ответ.КодСостояния = 207 Тогда
		ОписаниеОшибки = ПолучитьОписаниеОшибокHTTPВызова(НСтр("ru = 'Получение каталога пользователя завершилось ошибкой.'"), Ответ);
		ЗарегистрироватьОшибку(ОписаниеОшибки.КраткийТекстОшибки, ОписаниеОшибки.ПодробныйТекстОшибки);
		ВызватьИсключение ОписаниеОшибки.КраткийТекстОшибки;
	КонецЕсли;
	Попытка
		ОтветXDTO = СтрокаXMLВXDTO(СтрокаXML);
		КорневойКаталог = ОтветXDTO.response.propstat.prop.current_user_principal.href;
	Исключение
		ЗарегистрироватьОшибку(КраткоеПредставлениеОшибки(ИнформацияОбОшибке()),
			ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
		ВызватьИсключение;
	КонецПопытки;
	
	Возврат КорневойКаталог;
	
КонецФункции

Функция ВызватьМетод(Метод, Соединение, ПутьНаСервере, ТелоКакСтрока = "", Глубина = 0, ETag = "")
	
	Заголовки = Новый Соответствие;
	Заголовки.Вставить("User-Agent", "UNF");
	
	Если Метод = "PUT" Тогда
		Если ЗначениеЗаполнено(ETag) Тогда
			Заголовки.Вставить("If-Match", ETag);
		Иначе
			Заголовки.Вставить("If-None-Match", "*");
		КонецЕсли;
		Заголовки.Вставить("Content-Type", "text/calendar; charset=""utf-8""");
	ИначеЕсли Метод = "REPORT" ИЛИ Метод = "PROPFIND" Тогда
		Заголовки.Вставить("Depth", Глубина);
		Заголовки.Вставить("Content-Type", "application/xml; charset=""utf-8""");
	КонецЕсли;
	Запрос = Новый HTTPЗапрос(ПутьНаСервере, Заголовки);
	Если ЗначениеЗаполнено(ТелоКакСтрока) Тогда
		Запрос.УстановитьТелоИзСтроки(ТелоКакСтрока, "utf-8");
	КонецЕсли;
	Попытка
		Ответ = Соединение.ВызватьHTTPМетод(Метод, Запрос);
	Исключение
		ЗарегистрироватьОшибку(КраткоеПредставлениеОшибки(ИнформацияОбОшибке()),
			ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
		ВызватьИсключение;
	КонецПопытки;
	Возврат Ответ;
	
КонецФункции

Функция СтрокаXMLВXDTO(СтрокаXML)
	
	ЧтениеXML = Новый ЧтениеXML;
	ЧтениеXML.УстановитьСтроку(СтрокаXML);
	Возврат ФабрикаXDTO.ПрочитатьXML(ЧтениеXML);
	
КонецФункции

Функция СтруктураURIСервераCalDAV(Сервер)
	
	СтруктураURI = ОбщегоНазначенияКлиентСервер.СтруктураURI(Сервер);
	Если Не ЗначениеЗаполнено(СтруктураURI.Схема) Тогда
		СтруктураURI.Схема = "https";
		Если Не ЗначениеЗаполнено(СтруктураURI.Порт) Тогда
			СтруктураURI.Порт = 443;
			СтруктураURI.ИмяСервера = СтруктураURI.ИмяСервера + ":443";
		КонецЕсли;
	КонецЕсли;
	Возврат СтруктураURI;
	
КонецФункции

Функция HTTPСоединениеСервераCalDAV(СтруктураURI)
	
	ИнтернетПрокси = Неопределено;
	Если ОбщегоНазначения.ПодсистемаСуществует("СтандартныеПодсистемы.ПолучениеФайловИзИнтернета") Тогда
		МодульПолучениеФайловИзИнтернета = ОбщегоНазначения.ОбщийМодуль("ПолучениеФайловИзИнтернета");
		ИнтернетПрокси = МодульПолучениеФайловИзИнтернета.ПолучитьПрокси(СтруктураURI.Схема);
	КонецЕсли;
	Таймаут = 50;
	ЗащищенноеСоединение = ОбщегоНазначенияКлиентСервер.НовоеЗащищенноеСоединение();
	Возврат Новый HTTPСоединение(
		СтруктураURI.Хост,
		СтруктураURI.Порт,
		СтруктураURI.Логин,
		СтруктураURI.Пароль,
		ИнтернетПрокси, Таймаут,
		ЗащищенноеСоединение);
		
КонецФункции

Функция ДействительныйТокенСинхронизации(Соединение, СтруктураURI, Знач ТокенСинхронизации)
	
	ТелоКакСтрока =
	"<D:propfind xmlns:D=""DAV:"" xmlns:C=""http://calendarserver.org/ns/"">
	|	<D:prop>
	|		<C:getctag/>
	|	</D:prop>
	|</D:propfind>";
	Заголовки = Новый Соответствие;
	Заголовки.Вставить("Depth", 0);
	Заголовки.Вставить("Content-Type", "application/xml; charset=""utf-8""");
	Запрос = Новый HTTPЗапрос(СтруктураURI.ПутьНаСервере, Заголовки);
	Запрос.УстановитьТелоИзСтроки(ТелоКакСтрока, "utf-8");
	Попытка
		Ответ = Соединение.ВызватьHTTPМетод("PROPFIND", Запрос);
	Исключение
		ЗарегистрироватьОшибку(КраткоеПредставлениеОшибки(ИнформацияОбОшибке()),
			ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
		ВызватьИсключение;
	КонецПопытки;
	Если Ответ.КодСостояния = 207 Тогда
		ТаблицаОтвета = Новый ТаблицаЗначений;
		ТаблицаОтвета.Колонки.Добавить("getctag", Новый ОписаниеТипов("Строка"));
		ОбработатьMultiStatusОтвет(Ответ, ТаблицаОтвета);
		Если ЗначениеЗаполнено(ТаблицаОтвета) Тогда
			ТокенСинхронизации = ТаблицаОтвета[0].getctag;
		КонецЕсли;
	КонецЕсли;
	Возврат ТокенСинхронизации;
	
КонецФункции

Процедура ЗаполнитьИзмененными(ОписаниеКалендаря, Соединение, СтруктураURI, ДатаНачала , ДатаОкончания)
	
	События = ОписаниеКалендаря.События;
	ТипСобытия = ОписаниеКалендаря.ТипКалендаря;
	ТелоКакСтрока = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
	"<C:calendar-query xmlns:D=""DAV:""
	|				xmlns:C=""urn:ietf:params:xml:ns:caldav"">
	|	<D:prop>
	|		<D:getetag/>
	|	</D:prop>
	|	<C:filter>
	|		<C:comp-filter name=""VCALENDAR"">
	|			<C:comp-filter name=""%1"">
	|				<C:time-range start=""%2""
	|								end=""%3""/>
	|			</C:comp-filter>
	|		</C:comp-filter>
	|	</C:filter>
	|</C:calendar-query>",
	ТипСобытия,
	РаботаСICalendar.ДатаФорматаICalendar(ДатаНачала),
	РаботаСICalendar.ДатаФорматаICalendar(ДатаОкончания));
	Ответ = ВызватьМетод("REPORT", Соединение, СтруктураURI.ПутьНаСервере, ТелоКакСтрока, 1);
	Если Не Ответ.КодСостояния = 207 Тогда
		Возврат;
	КонецЕсли;
	
	ТаблицаОтвета = Новый ТаблицаЗначений;
	ТаблицаОтвета.Колонки.Добавить("getetag", Новый ОписаниеТипов("Строка"));
	ТаблицаОтвета.Колонки.Добавить("href", Новый ОписаниеТипов("Строка"));
	ОбработатьMultiStatusОтвет(Ответ, ТаблицаОтвета);
	
	ТелоКакСтрока = ТелоЗапросаИзменений(СтруктураURI.ПутьНаСервере, ОписаниеКалендаря, ТаблицаОтвета);
	Если Не ЗначениеЗаполнено(ТелоКакСтрока) Тогда
		Возврат;
	КонецЕсли;
	Ответ = ВызватьМетод("REPORT", Соединение, СтруктураURI.ПутьНаСервере, ТелоКакСтрока, 1);
	Если Не Ответ.КодСостояния = 207 Тогда
		Возврат;
	КонецЕсли;
	Соответствие = Новый Соответствие;
	Соответствие.Вставить("getetag", "ОтпечатокОбъекта");
	ОбработатьMultiStatusОтвет(Ответ, События, Соответствие, Истина);

	
	
КонецПроцедуры

Процедура ЗаполнитьВсемиСобытиями(ОписаниеКалендаря, Соединение, СтруктураURI, ДатаНачала, ДатаОкончания)
	
	События = ОписаниеКалендаря.События;
	ТипСобытия = ОписаниеКалендаря.ТипКалендаря;
	ТелоКакСтрока = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
	"<C:calendar-query xmlns:D=""DAV:""
	|				xmlns:C=""urn:ietf:params:xml:ns:caldav"">
	|	<D:prop>
	|		<D:getetag/>
	|		<C:calendar-data>
	|			<C:comp name=""VCALENDAR"">
	|				<C:comp name=""VEVENT"">
	|					<C:prop name=""SUMMARY""/>
	|					<C:prop name=""UID""/>
	|					<C:prop name=""DTSTART""/>
	|					<C:prop name=""DTEND""/>
	|					<C:prop name=""RRULE""/>
	|					<C:prop name=""EXDATE""/>
	|				</C:comp>
	|			</C:comp>
	|		</C:calendar-data>
	|	</D:prop>
	|	<C:filter>
	|		<C:comp-filter name=""VCALENDAR"">
	|			<C:comp-filter name=""%1"">
	|				<C:time-range start=""%2""
	|								end=""%3""/>
	|			</C:comp-filter>
	|		</C:comp-filter>
	|	</C:filter>
	|</C:calendar-query>",
	ТипСобытия,
	РаботаСICalendar.ДатаФорматаICalendar(ДатаНачала),
	РаботаСICalendar.ДатаФорматаICalendar(ДатаОкончания));
	Ответ = ВызватьМетод("REPORT", Соединение, СтруктураURI.ПутьНаСервере, ТелоКакСтрока, 1);
	Если Не Ответ.КодСостояния = 207 Тогда
		Возврат;
	КонецЕсли;
	Соответствие = Новый Соответствие;
	Соответствие.Вставить("getetag", "ОтпечатокОбъекта");
	ОбработатьMultiStatusОтвет(Ответ, События, Соответствие, Истина);
	
КонецПроцедуры

Функция ОбработатьMultiStatusОтвет(Ответ, ТаблицаОтвета, СоответствиеИменСвойств = Неопределено, ПолучатьДанныеКалендаря = Ложь)
	
	Попытка
		Если Не ЗначениеЗаполнено(СоответствиеИменСвойств) Тогда
			СоответствиеИменСвойств = Новый Соответствие;
		КонецЕсли;
		СтрокаXML  = Ответ.ПолучитьТелоКакСтроку();
		ЧтениеXML = Новый ЧтениеXML;
		ЧтениеXML.УстановитьСтроку(СтрокаXML);
		ОтветXDTO = ФабрикаXDTO.ПрочитатьXML(ЧтениеXML);
		ЧтениеXML.Закрыть();
		Если ОтветXDTO.Свойства().Получить("response") = Неопределено Тогда
			Возврат ТаблицаОтвета;
		КонецЕсли;
		Если ТаблицаОтвета.Колонки.Найти("href") = Неопределено Тогда
			ТаблицаОтвета.Колонки.Добавить("href", Новый ОписаниеТипов("Строка"));
		КонецЕсли;
		Если Не ТипЗнч(ОтветXDTO.response) = Тип("СписокXDTO") Тогда
			СписокResponse = Новый Массив;
			СписокResponse.Добавить(ОтветXDTO.response);
		Иначе
			СписокResponse = ОтветXDTO.response;
		КонецЕсли;
		Для Каждого response Из СписокResponse Цикл
			НоваяСтрока = ТаблицаОтвета.Добавить();
			НоваяСтрока.href = response.href;
			Если ПолучатьДанныеКалендаря И Не response.Свойства().Получить("status") = Неопределено Тогда
				Если СтрНайти(response.status, "404") > 0 Тогда
					НоваяСтрока.Идентификатор = ВыделитьИдентификатор(НоваяСтрока.href);
					НоваяСтрока.ПометкаУдаления = Истина;
					Продолжить;
				КонецЕсли;
			КонецЕсли;
			Если Не ТипЗнч(response.propstat) = Тип("СписокXDTO") Тогда
				СписокPropstat = Новый Массив;
				СписокPropstat.Добавить(response.propstat);
			ИначеЕсли ТипЗнч(response.propstat) = Тип("СписокXDTO") Тогда
				СписокPropstat = response.propstat;
			КонецЕсли;
			Для Каждого propstat Из СписокPropstat Цикл
				Если СтрНайти(propstat.status, "200") > 0 Тогда
					Свойства = propstat.prop.Свойства();
					Для Каждого Свойство Из Свойства Цикл
						Если ПолучатьДанныеКалендаря И Свойство.Имя = "calendar_data" Тогда
							СтруктураiCalendar = РаботаСICalendar.СтруктураiCalendar(propstat.prop[Свойство.Имя]);
							Если ТипЗнч(СтруктураiCalendar) = Тип ("Структура") Тогда
								ЗаполнитьЗначенияСвойств(НоваяСтрока, СтруктураiCalendar);
							КонецЕсли;
						ИначеЕсли Не СоответствиеИменСвойств.Получить(Свойство.Имя) = Неопределено Тогда
							НоваяСтрока[СоответствиеИменСвойств.Получить(Свойство.Имя)] = propstat.prop[Свойство.Имя];
						ИначеЕсли Не ТаблицаОтвета.Колонки.Найти(Свойство.Имя) = Неопределено Тогда
							НоваяСтрока[Свойство.Имя] = propstat.prop[Свойство.Имя];
						КонецЕсли;
					КонецЦикла;
					Прервать;
				КонецЕсли;
			КонецЦикла;
		КонецЦикла;
	Исключение
		ЗарегистрироватьОшибку(КраткоеПредставлениеОшибки(ИнформацияОбОшибке()),
			ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
		ВызватьИсключение;
	КонецПопытки;
	
КонецФункции

Функция ТелоЗапросаНаИзменениеНаименованияВнешнегоКалендаря(НовоеИмяКалендаря)
	
	ТелоКакСтрока = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
	"<D:propertyupdate xmlns:D=""DAV:"">
	|	<D:set>
	|		<D:prop>
	|			<D:displayname>%1</D:displayname>
	|		</D:prop>
	|	</D:set>
	|</D:propertyupdate>",
	НовоеИмяКалендаря);
	
	Возврат ТелоКакСтрока;
	
КонецФункции

Функция ВыделитьИдентификатор(Знач Путь)
	
	Путь = ?(Прав(Путь, 1) = "/", Лев(Путь, СтрДлина(Путь) - 1), Путь);
	Позиция = СтрНайти(Путь, "/");
	Пока Позиция > 0 Цикл
		Путь = Прав(Путь, СтрДлина(Путь) - Позиция);
		Позиция = СтрНайти(Путь, "/");
	КонецЦикла;
	Возврат СокрЛП(СтрЗаменить(Путь, ".ics", ""));
	
КонецФункции

Функция ПутьИзИдентификаторов(Знач ПутьНаСервере, Знач Идентификатор)
	
	ПутьНаСервере = ?(Прав(ПутьНаСервере, 1) = "/", Лев(ПутьНаСервере, СтрДлина(ПутьНаСервере) - 1), ПутьНаСервере);
	ПутьНаСервере = ?(Лев(ПутьНаСервере, 1) = "/", Прав(ПутьНаСервере, СтрДлина(ПутьНаСервере) - 1), ПутьНаСервере);
	Возврат "/" + ПутьНаСервере + "/" + Идентификатор + ".ics";
	
КонецФункции

Функция ТелоЗапросаИзменений(ПутьНаСервере, ОписаниеКалендаря, ТаблицаEtag)
	
	МаксДлинаИдентификатор = 1;
	МаксДлинаEtag = 1;
	ТаблицаEtag.Колонки.Добавить("Идентификатор", Новый ОписаниеТипов("Строка"));
	Для Каждого СтрокаEtag Из ТаблицаEtag Цикл
		СтрокаEtag.Идентификатор = ВыделитьИдентификатор(СтрокаEtag.href);
		МаксДлинаИдентификатор = ?(СтрДлина(СтрокаEtag.Идентификатор) > МаксДлинаИдентификатор,
			СтрДлина(СтрокаEtag.Идентификатор), МаксДлинаИдентификатор);
		МаксДлинаEtag = ?(СтрДлина(СтрокаEtag.getetag) > МаксДлинаEtag, СтрДлина(СтрокаEtag.getetag), МаксДлинаEtag);
	КонецЦикла;
	
	Запрос = Новый Запрос(
	"ВЫБРАТЬ
	|	ТаблицаEtag.Идентификатор КАК Идентификатор,
	|	ТаблицаEtag.href КАК href,
	|	ТаблицаEtag.getetag КАК getetag
	|ПОМЕСТИТЬ ТаблицаEtag
	|ИЗ
	|	&ТаблицаEtag КАК ТаблицаEtag
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	ЕСТЬNULL(ТаблицаEtag.Идентификатор, ДанныеСобытийВнешнихКалендарей.Идентификатор) КАК Идентификатор
	|ИЗ
	|	ТаблицаEtag КАК ТаблицаEtag
	|		ЛЕВОЕ СОЕДИНЕНИЕ РегистрСведений.ДанныеСобытийВнешнихКалендарей КАК ДанныеСобытийВнешнихКалендарей
	|		ПО (ПОДСТРОКА(ЕСТЬNULL(ТаблицаEtag.Идентификатор, """"), 0, &МаксДлинаИдентификатор) = ПОДСТРОКА(ЕСТЬNULL(ДанныеСобытийВнешнихКалендарей.Идентификатор, """"), 0, &МаксДлинаИдентификатор))
	|ГДЕ
	|	ТаблицаEtag.href ПОДОБНО ""%.ics"" И
	|	ВЫБОР
	|			КОГДА ДанныеСобытийВнешнихКалендарей.ОтпечатокОбъекта ЕСТЬ NULL
	|				ТОГДА ИСТИНА
	|			ИНАЧЕ НЕ ПОДСТРОКА(ЕСТЬNULL(ТаблицаEtag.getetag, """"), 0, &МаксДлинаEtag) = ПОДСТРОКА(ЕСТЬNULL(ДанныеСобытийВнешнихКалендарей.ОтпечатокОбъекта, """"), 0, &МаксДлинаEtag)
	|					И ПОДСТРОКА(ДанныеСобытийВнешнихКалендарей.ИдентификаторКалендаря, 0, &ДлинаИдентификатораКалендаря) = &ИдентификаторКалендаря
	|		КОНЕЦ");
	Запрос.УстановитьПараметр("ТаблицаEtag", ТаблицаEtag);
	Запрос.УстановитьПараметр("ИдентификаторКалендаря", ОписаниеКалендаря.Идентификатор);
	Запрос.УстановитьПараметр("ДлинаИдентификатораКалендаря", СтрДлина(ОписаниеКалендаря.Идентификатор));
	Запрос.УстановитьПараметр("МаксДлинаИдентификатор", МаксДлинаИдентификатор);
	Запрос.УстановитьПараметр("МаксДлинаEtag", МаксДлинаEtag);
	РезультатЗапроса = Запрос.Выполнить();
	Если РезультатЗапроса.Пустой() Тогда
		Возврат "";
	КонецЕсли;
	СтрокаСсылок = "";
	Выборка = РезультатЗапроса.Выбрать();
	Пока Выборка.Следующий() Цикл
		Путь = ПутьИзИдентификаторов(ПутьНаСервере, Выборка.Идентификатор);
		СтрокаСсылок = СтрокаСсылок + Символы.ПС + СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			"	<D:href>%1</D:href>", Путь);
	КонецЦикла;
	ТелоКакСтрока = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
	"<C:calendar-multiget xmlns:D=""DAV:""
	|					xmlns:C=""urn:ietf:params:xml:ns:caldav"">
	|	<D:prop>
	|		<D:getetag/>
	|		<C:calendar-data/>
	|	</D:prop>%1
	|</C:calendar-multiget>", СтрокаСсылок);
	Возврат ТелоКакСтрока;
	
КонецФункции

Функция ПолучитьОписаниеОшибокHTTPВызова(КраткийТекстОшибки, Ответ)
	
	Если Ответ.КодСостояния = 401 ИЛИ Ответ.КодСостояния = 403 Тогда
		КраткийТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = '%1 Неправильная комбинация логина и пароля.'"), КраткийТекстОшибки);
	КонецЕсли;
	
	ПодробныйТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
		НСтр("ru = 'Сервер вернул состояние: %1
					|Тело ответа: %2'"), Ответ.КодСостояния, Ответ.ПолучитьТелоКакСтроку());
	
	ТекстОшибок = Новый Структура;
	ТекстОшибок.Вставить("КраткийТекстОшибки", КраткийТекстОшибки);
	ТекстОшибок.Вставить("ПодробныйТекстОшибки", ПодробныйТекстОшибки);
	
	Возврат ТекстОшибок;
	
КонецФункции

Процедура ЗарегистрироватьОшибку(КраткийТекстОшибки, ПодробныйТекстОшибки, ПоказыватьСообщения = Ложь)
	
	ИмяСобытия = НСтр("ru = 'Синхронизация календарей.DAV'", ОбщегоНазначения.КодОсновногоЯзыка());
	ЗаписьЖурналаРегистрации(ИмяСобытия, УровеньЖурналаРегистрации.Ошибка,,, ПодробныйТекстОшибки);
	Если Не ПоказыватьСообщения Тогда
		Возврат;
	КонецЕсли;
	ТекстСообщения = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
		НСтр("ru = 'При синхронизации возникла ошибка. Обратитесь к администратору.
					|Текст ошибки:
					|%1'"),
		КраткийТекстОшибки);
	ОбщегоНазначения.СообщитьПользователю(ТекстСообщения);
	
КонецПроцедуры

Функция ТолькоЦифрыВСтроке(Знач Значение, Знач Устаревший = Истина, Знач ПробелыЗапрещены = Истина)
	
	Если ТипЗнч(Значение) <> Тип("Строка") Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Если Не ПробелыЗапрещены Тогда
		Значение = СтрЗаменить(Значение, " ", "");
	КонецЕсли;
		
	Если СтрДлина(Значение) = 0 Тогда
		Возврат Истина;
	КонецЕсли;
	
	// Если содержит только цифры, то в результате замен должна быть получена пустая строка.
	// Проверять при помощи ПустаяСтрока нельзя, так как в исходной строке могут быть пробельные символы.
	Возврат СтрДлина(
		СтрЗаменить( СтрЗаменить( СтрЗаменить( СтрЗаменить( СтрЗаменить(
		СтрЗаменить( СтрЗаменить( СтрЗаменить( СтрЗаменить( СтрЗаменить( 
			Значение, "0", ""), "1", ""), "2", ""), "3", ""), "4", ""), "5", ""), "6", ""), "7", ""), "8", ""), "9", "")) = 0;
	
КонецФункции

#КонецОбласти