
// Подсистема "Электронный документооборот с контролирующими органами".
//
////////////////////////////////////////////////////////////////////////////////

#Область ПрограммныйИнтерфейс

// Базовая функция для обработки файла формата PDF.
//
// Основые операции:
//	- получение потока данных файла
// 	- получение версия PDF
//	- переход в конец файла, получение позиции описательной части
//	- чтение таблицы ссылок на объекты, в т.ч. в потоковом формате
//	- получение начального объекта или прицепа
//	- получение дополнительной информации о файле: кем и когда создан
//	- составление реестра страниц
//	- получение текста страниц
//
// Параметры:
//	СодержаниеДокумента 	- ДвоичныеДанные
//							- Поток
//							- Строка - имя файла
//	ПараметрыОбъекта 		- Структура - проверяются следующие ключи:
//		* РежимПарсинга		- Строка - по умолчанию Текст
//		* СообщатьОшибки 	- Булево
//		* ДетальныйАнализПроизводительности - Булево
//
// Возвращаемое значение:
//	Структура
//
Функция ПодготовитьСводкуДокументаPDF(СодержаниеДокумента, ПараметрыОбъекта = Неопределено) Экспорт
	
	НачалоОперации = ТекущаяУниверсальнаяДатаВМиллисекундах();
	ТекущийОтсчет = НачалоОперации;
	
	ОбъектДокумента = ДанныеПарсингаФайла(НачалоОперации);
	ОбъектДокумента.РежимПарсинга = ПолучитьЗначение(ПараметрыОбъекта, "РежимПарсинга", "Текст");
	ОбъектДокумента.СообщатьОшибки = ПолучитьЗначение(ПараметрыОбъекта, "СообщатьОшибки", Ложь);
	ОбъектДокумента.ДетальныйАнализПроизводительности = ПолучитьЗначение(ПараметрыОбъекта, "ДетальныйАнализПроизводительности", Ложь);
	ОтразитьСостояниеЗамера(ОбъектДокумента, "Инициализация", ТекущийОтсчет);
	
	НаборСимволов = ОбъектДокумента.НаборСимволов;
	
	Если ТипЗнч(СодержаниеДокумента) = Тип("Поток") Тогда
		ОбъектДокумента.ПотокДанных = СодержаниеДокумента;
	ИначеЕсли ТипЗнч(СодержаниеДокумента) = Тип("ДвоичныеДанные") Тогда
		ЧтениеДанных = Новый ЧтениеДанных(СодержаниеДокумента);
		ОбъектДокумента.ПотокДанных = ЧтениеДанных.ИсходныйПоток();
		ЧтениеДанных = Неопределено;;
	Иначе
		ОбъектДокумента.ПотокДанных = ФайловыеПотоки.ОткрытьДляЧтения(СодержаниеДокумента);
	КонецЕсли;
	ОбъектДокумента.Инициализирован = Ложь;
	ОтразитьСостояниеЗамера(ОбъектДокумента, "Подготовка данных", ТекущийОтсчет);
	
	РазмерФайла = ОбъектДокумента.ПотокДанных.Размер();
	
	ОбъектДокумента.Замер = ТекущаяУниверсальнаяДатаВМиллисекундах();

	Попытка
		ОбъектДокумента.МетаИнформация.Версия = ИзвлечьВерсию(ОбъектДокумента);
		
		Если ЗначениеЗаполнено(ОбъектДокумента.МетаИнформация.Версия) Тогда
			// Ищем таблицу объектов
			УсловныйРазмер = 7 + 100 + СтрДлина(НаборСимволов.ПозицияОписания); // смещение позиции с описательной частью
			ДанныеБлока = ПрочитатьДанныеПотока(ОбъектДокумента, УсловныйРазмер, РазмерФайла - УсловныйРазмер, Истина);
			Позиция = СтрНайти(ДанныеБлока, НаборСимволов.ПозицияОписания, НаправлениеПоиска.СКонца);
			ПозицияОкончания = СтрНайти(ДанныеБлока, НаборСимволов.ОкончаниеФайла, НаправлениеПоиска.СКонца);
			ОтразитьСостояниеЗамера(ОбъектДокумента, "Позиционирование в файле", ТекущийОтсчет);
			
			ОбъектДокумента.УскоритьПолучениеСтраниц = НЕ ЕстьРежим(ОбъектДокумента, "Текст");
		
			Если ПозицияОкончания > 0 И Позиция > 0 Тогда
				ОбъектДокумента.НачальноеЧтение = Истина;
				ПерейтиКПозицииДанных(ОбъектДокумента, РазмерФайла - УсловныйРазмер + Позиция - 1);
				ПрочитатьРазделДокумента(ОбъектДокумента);
				ОбъектДокумента.НачальноеЧтение = Ложь;
			КонецЕсли;
			ОтразитьСостояниеЗамера(ОбъектДокумента, "Чтение таблицы объектов", ТекущийОтсчет);
			
			ОбъектДокумента.Инициализирован = ОбъектДокумента.Объекты.Количество() > 0;
			
			Если ОбъектДокумента.Инициализирован Тогда
				
				УзелСтраниц = Неопределено;
				ТочкаНачала = ИзвлечьИнформациюОДокументе(ОбъектДокумента);
				ОтразитьСостояниеЗамера(ОбъектДокумента, "Информация о документе", ТекущийОтсчет);
				
				Если ТочкаНачала <> Неопределено Тогда
					УзелСтраниц = ПолучитьЗначение(ТочкаНачала, "Pages");
				КонецЕсли;
				
				Если УзелСтраниц <> Неопределено И ЗначениеЗаполнено(ОбъектДокумента.РежимПарсинга) Тогда
					ВыборкаДереваСтраниц(ОбъектДокумента, УзелСтраниц);
				КонецЕсли;
				
				ОтразитьСостояниеЗамера(ОбъектДокумента, "Дерево страниц", ТекущийОтсчет);
				
				РежимПарсингаСканы(ОбъектДокумента, ТекущийОтсчет);
				РежимПарсингаПодписи(ОбъектДокумента, ТочкаНачала, ТекущийОтсчет);
				РежимПарсингаТекст(ОбъектДокумента, ТекущийОтсчет);
				
			КонецЕсли;
		КонецЕсли;
	
	Исключение
		
		ИнформацияОбОшибке = ИнформацияОбОшибке();
		
		ОбъектДокумента.Инициализирован = Ложь;
		ВывестиПротокол(ОбъектДокумента, ИнформацияОбОшибке);
		
		ДокументооборотСКО.ОбработатьИсключение(ИнформацияОбОшибке, "Парсинг PDF");
		
	КонецПопытки;
	
	ОкончаниеОперации = ТекущаяУниверсальнаяДатаВМиллисекундах();
	ОбъектДокумента.ОценкаПроизводительности = ОкончаниеОперации - НачалоОперации;
	
	Возврат ОбъектДокумента;
	
КонецФункции

// Параметры:
//	СодержаниеДокумента 	- ДвоичныеДанные
//							- Поток
//							- Строка - имя файла
//	ПараметрыОбъекта 		- Структура - проверяются следующие ключи:
//		* РежимПарсинга		- Строка - по умолчанию Текст
//		* СообщатьОшибки 	- Булево
//		* ДетальныйАнализПроизводительности - Булево
//
// Возвращаемое значение:
//	Структура
//
Функция ПолучитьДанныеТребованияИзФайлаPDF(ДвДанные, ПараметрыОбъекта = Неопределено) Экспорт
	
	Результат = Новый Структура();
	Результат.Вставить("ДнейДоОтвета",  0);
	
	ДанныеДокумента = ПодготовитьСводкуДокументаPDF(ДвДанные, ПараметрыОбъекта);
	
	Если ЗначениеЗаполнено(ДанныеДокумента.ТекстДокумента) Тогда
		Результат.ДнейДоОтвета = КоличествоДнейНаОтвет(ДанныеДокумента.ТекстДокумента);
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

Функция ПлатформаПоддерживаетДокументPDF() Экспорт
	
	СистемнаяИнформация = Новый СистемнаяИнформация;
	Поддерживает = ОбщегоНазначенияКлиентСервер.СравнитьВерсии(
		СистемнаяИнформация.ВерсияПриложения, 
		"8.3.21.1") >= 0;
	
	Возврат Поддерживает;
	
КонецФункции

Функция ЭтоPDFa3Файл_Платформой(ДвДанные) Экспорт
	
	ИмяФайла = ПолучитьИмяВременногоФайла("pdf");
	ДвДанные.Записать(ИмяФайла);
	
	ЭтоPDFa3 = Ложь;
	
	PDF_A_3Строкой = "ТипФайлаДокументаPDF.PDF_A_3";
	ТипДокументPDF = "ДокументPDF";
	
	PDFФайл = Новый(ТипДокументPDF);
	PDFФайл.Прочитать(ИмяФайла);
	ЭтоPDFa3 = PDFФайл.ТипФайла = ПредопределенноеЗначение(PDF_A_3Строкой);
	
	Возврат ЭтоPDFa3;
	
КонецФункции

Функция ЭтоPDFa3Файл_ПоМетаинформации(Метаинформация) Экспорт
	
	Возврат Метаинформация.ФорматАрхива = "A/3";
	
КонецФункции

// Параметры:
//  ОписаниеФайлов	 - Адрес, Имя
//
Функция СвойстваPDFФайла(ОписаниеФайла) Экспорт
	
	ОписаниеФайла.Вставить("ЭтоPDF",      Ложь);
	ОписаниеФайла.Вставить("ЭтоPDFa3",    Ложь);
	ОписаниеФайла.Вставить("ЕстьВстроеннаяПодпись", Ложь);
	ОписаниеФайла.Вставить("ЭтоСкан",     Ложь);
	ОписаниеФайла.Вставить("ВидPDF",      Неопределено);
	
	ЭтоНовыйФормат = ТребованияФНСКлиентСервер.ЭтоФормат_ON_DOCNPNO_1_886_00_05_02();
	Если НЕ ЭтоНовыйФормат Тогда
		Возврат ОписаниеФайла;
	КонецЕсли;
	
	ЭтоPDFФайл = ОбработкаФайловPDFКлиентСервер.ЭтоPDFФайл(ОписаниеФайла.Имя); 
	Если НЕ ЭтоPDFФайл Тогда
		Возврат ОписаниеФайла;
	КонецЕсли;
	
	ДвДанные = ПолучитьИзВременногоХранилища(ОписаниеФайла.Адрес);
	
	ПараметрыОбъекта = Новый Структура("РежимПарсинга", "Сканы");
	Метаинформация = ПодготовитьСводкуДокументаPDF(ДвДанные, ПараметрыОбъекта).Метаинформация;
	
	Если ПлатформаПоддерживаетДокументPDF() Тогда
		Попытка
			ЭтоPDFa3 = ЭтоPDFa3Файл_Платформой(ДвДанные);
		Исключение
			ЭтоPDFa3 = ЭтоPDFa3Файл_ПоМетаинформации(Метаинформация);
		КонецПопытки;
	Иначе
		ЭтоPDFa3 = ЭтоPDFa3Файл_ПоМетаинформации(Метаинформация);
	КонецЕсли;
	
	ЭтоСкан = Метаинформация.СканированноеИзображение = Истина;
	ЕстьПодпись = Метаинформация.ЕстьПодпись = Истина;
	
	Если ЭтоPDFa3 Тогда
		ВидPDF = Перечисления.ВидыPDF.PDFa3;
	ИначеЕсли ЭтоСкан Тогда
		ВидPDF = Перечисления.ВидыPDF.ДокСкан;
	Иначе
		ВидPDF = Перечисления.ВидыPDF.ДокPDF;
	КонецЕсли;
		
	ОписаниеФайла.Вставить("ЭтоPDF",      Истина);
	ОписаниеФайла.Вставить("ЭтоPDFa3",    ЭтоPDFa3);
	ОписаниеФайла.Вставить("ЕстьВстроеннаяПодпись", ЕстьПодпись);
	ОписаниеФайла.Вставить("ЭтоСкан",     ЭтоСкан);
	ОписаниеФайла.Вставить("ВидPDF",      ВидPDF);
	
	Возврат ОписаниеФайла;
	
КонецФункции

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

#Область БазовыеОбъекты

// Описывает объект-структуру для организации парсинга PDF данных.
//
// Возвращаемое значение:
//	Структура
//
Функция ДанныеПарсингаФайла(НачалоОперации = 0)
	
	НаборСимволов = Новый Структура;
	
	СпецСимволы = Новый Структура;
	СпецСимволы.Вставить("НачалоМассива", "[");
	СпецСимволы.Вставить("ОкончаниеМассива", "]");
	СпецСимволы.Вставить("НачалоСловаря", "<<");
	СпецСимволы.Вставить("ОкончаниеСловаря", ">>");
	СпецСимволы.Вставить("Имя", "/");
	СпецСимволы.Вставить("Комментарий", "%");
	СпецСимволы.Вставить("НачалоHEXСтроки", "<");
	СпецСимволы.Вставить("ОкончаниеHEXСтроки", ">");
	СпецСимволы.Вставить("НачалоВыражения", "{");
	СпецСимволы.Вставить("ОкончаниеВыражения", "}");
	СпецСимволы.Вставить("НачалоСтроки", "(");
	СпецСимволы.Вставить("ОкончаниеСтроки", ")");
	
	ОсобыйНабор = "";
	Для Каждого СтрокаКлюча Из СпецСимволы Цикл
		ОсобыйНабор = ОсобыйНабор + СтрокаКлюча.Значение;
	КонецЦикла;
	НаборСимволов.Вставить("СпецСимволы", ОсобыйНабор);
	
	СимволыПробела = Новый Структура;
	СимволыПробела.Вставить("Пустой", Символ(0));
	СимволыПробела.Вставить("Пробел", " ");
	СимволыПробела.Вставить("Табуляция", Символы.Таб);
	СимволыПробела.Вставить("ПереводСтроки", Символы.ПС);
	СимволыПробела.Вставить("ВозвратКаретки", Символы.ВК);
	СимволыПробела.Вставить("ПереводФормы", Символы.ПФ);
	
	ОсобыйНабор = "";
	Для Каждого СтрокаКлюча Из СимволыПробела Цикл
		ОсобыйНабор = ОсобыйНабор + СтрокаКлюча.Значение;
	КонецЦикла;
	НаборСимволов.Вставить("СимволыПробела", ОсобыйНабор);
	
	НаборСимволов.Вставить("Ссылка", "R");
	НаборСимволов.Вставить("Экран", "\");
	НаборСимволов.Вставить("КодСимвола", "#");
	НаборСимволов.Вставить("НачалоОбъекта", "obj");
	НаборСимволов.Вставить("ОкончаниеОбъекта", "endobj");
	НаборСимволов.Вставить("НачалоПотока", "stream");
	НаборСимволов.Вставить("ОкончаниеПотока", "endstream");
	НаборСимволов.Вставить("НачалоОписания", "xref");
	НаборСимволов.Вставить("ПозицияОписания", "startxref");
	НаборСимволов.Вставить("ОкончаниеФайла", "%%EOF");
	НаборСимволов.Вставить("Прицеп", "trailer");
	НаборСимволов.Вставить("НачалоВставки", "<?");
	НаборСимволов.Вставить("ОкончаниеВставки", "?>");
	
	// анализ объекта с текстом
	НаборСимволов.Вставить("НачалоТекста", "BT");
	НаборСимволов.Вставить("ОкончаниеТекста", "ET");
	НаборСимволов.Вставить("МаркерОдинарнаяКавычка", Символ(39)); // показать с переносом
	НаборСимволов.Вставить("МаркерДвойнаяКавычка", Символ(34)); // показать с переносом на позиции
	НаборСимволов.Вставить("МаркерОтобразить", "TJ");
	НаборСимволов.Вставить("МаркерСПозицией", "Tj");
	НаборСимволов.Вставить("МаркерШрифта", "Tf");
	НаборСимволов.Вставить("МаркерПереноса", "T*");
	НаборСимволов.Вставить("МаркерПереносаНаПозицию", "Td");
	НаборСимволов.Вставить("МаркерПереносаНаПозицию1", "TD");
	НаборСимволов.Вставить("МаркерПробела", "Tc");
	
	ОбщегоНазначенияКлиентСервер.ДополнитьСтруктуру(НаборСимволов, СимволыПробела, Истина);
	ОбщегоНазначенияКлиентСервер.ДополнитьСтруктуру(НаборСимволов, СпецСимволы, Истина);
	
	ВсеЭкраны = Новый Соответствие;
	ВсеЭкраны.Вставить("\n", Символы.ПС);
	ВсеЭкраны.Вставить("\r", Символы.ВК);
	ВсеЭкраны.Вставить("\t", Символы.Таб);
	ВсеЭкраны.Вставить("\b", Символ(8));
	ВсеЭкраны.Вставить("\f", Символы.ПФ);
	ВсеЭкраны.Вставить("\(", "(");
	ВсеЭкраны.Вставить("\)", ")");
	ВсеЭкраны.Вставить("\\", "\");
	
	Результат = Новый Структура;
	Результат.Вставить("ТипОбъекта", "Файл");
	Результат.Вставить("НаборСимволов", НаборСимволов);
	Результат.Вставить("ЭкраныСимволов", ВсеЭкраны);
	Результат.Вставить("Объекты", Новый Соответствие);
	Результат.Вставить("ПотокДанных", Неопределено);
	Результат.Вставить("Кодировка", КодировкаТекста.ANSI);
	Результат.Вставить("МетаИнформация", ОбъектМетаИнформации());
	Результат.Вставить("Инициализирован", Ложь);
	Результат.Вставить("СообщатьОшибки", Истина);
	Результат.Вставить("РежимПарсинга", "Текст"); // Текст - разбирает только объекты для извлечения текста
	Результат.Вставить("НачальныйРаздел", Неопределено);
	Результат.Вставить("Страницы", Новый Массив);
	Результат.Вставить("Шрифты", Новый Соответствие);
	Результат.Вставить("ТекстДокумента", "");
	Результат.Вставить("НачальноеЧтение", Ложь);
	Результат.Вставить("ТекстОшибки", "");
	Результат.Вставить("НеобрабатывватьHEXСтроки", Ложь);
	Результат.Вставить("УскоритьПолучениеСтраниц", Ложь);
	
	// оценка производительности
	Результат.Вставить("ОценкаПроизводительности", НачалоОперации); // в миллисекундах
	Результат.Вставить("ДетальныйАнализПроизводительности", Ложь);
	Результат.Вставить("СписокОпераций", Новый Соответствие);
	Результат.Вставить("Замер", 0);
	
	Возврат Результат;
	
КонецФункции

// Описывает объект-структуру для хранения информации о шрифте.
//
// Возвращаемое значение:
//	Структура
//
Функция ОбъектШрифта()
	
	Результат = Новый Структура();
	Результат.Вставить("ТипОбъекта", "Информация");
	Результат.Вставить("ТипШрифта", "");
	Результат.Вставить("ТипКодировки", "StandartEncoding");
	// WinAnsiEncoding
	// Identity-H
	// Identity-V
	Результат.Вставить("Байтов", 1);
	Результат.Вставить("ТаблицаСоответствия", Новый Соответствие);
	Результат.Вставить("Потомок", Неопределено);
	
	Возврат Результат;
	
КонецФункции

// Описывает объект-структуру объекта строки: BT and ET
//
// Возвращаемое значение:
//	Структура
//
Функция ОбъектКодированнойСтроки()
	
	Результат = Новый Структура();
	Результат.Вставить("ТипОбъекта", "КодированнаяСтрока");
	Результат.Вставить("Содержание", "");
	Результат.Вставить("ЭтоПеренос", Ложь);
	Результат.Вставить("Маркер", "");
	Результат.Вставить("Шрифт", "");
	Результат.Вставить("СимвольныйСдвиг", Неопределено);
	
	Возврат Результат;
	
КонецФункции

// Описывает объект-структуру сводной информаци PDF.
//
// Возвращаемое значение:
//	Структура
//
Функция ОбъектМетаИнформации()
	
	Результат = Новый Структура;
	Результат.Вставить("ТипОбъекта", "Информация");
	Результат.Вставить("ДатаСоздания", Неопределено); // CreationDate
	Результат.Вставить("ДатаИзменения", Неопределено); // ModDate
	Результат.Вставить("Создан", ""); // Creator
	Результат.Вставить("Изменен", ""); // Producer
	Результат.Вставить("Идентификатор", Новый Массив); // ID
	Результат.Вставить("Версия", "");
	Результат.Вставить("ФорматАрхива", ""); // A/3, A/2, A/1
	Результат.Вставить("Подписи", Новый Массив);
	Результат.Вставить("ЕстьПодпись", Ложь);
	// определяется по косвенным признакам
	// перебираются страницы - одно изображение
	Результат.Вставить("СканированноеИзображение", Неопределено);
	
	Возврат Результат;
	
КонецФункции

// Описывает объект-структуру текущей текстовой строки парсинга.
//
// Возвращаемое значение:
//	Структура
//
Функция ОбъектДляПарсинга(Владелец, ТекущееСодержание = "")
	
	Результат = Новый Структура;
	
	Результат.Вставить("ТипОбъекта", "Строка");
	Результат.Вставить("Позиция", 1); // кеш текущей переменной
	Результат.Вставить("Содержимое", ТекущееСодержание); // содержимое текущего объекта
	Результат.Вставить("Длина", СтрДлина(ТекущееСодержание)); // длина содержимого текущего объекта
	Результат.Вставить("Владелец", Владелец); // длина содержимого текущего объекта
	Результат.Вставить("Комментарий", ""); // содержит текст комментария
	
	Возврат Результат;
	
КонецФункции

// Описывает объект-структуру Indirect PDF - ссылки на объект.
//
// Возвращаемое значение:
//	Структура
//
Функция ДанныеСсылкиОбъекта(НомерОбъекта = Неопределено, Версия = Неопределено)
	
	Результат = Новый Структура;
	
	Результат.Вставить("ТипОбъекта", "Ссылка");
	Результат.Вставить("Номер", НомерОбъекта);
	Результат.Вставить("Версия", Версия);
	Результат.Вставить("ПолеПоиска", "");
	
	Если НомерОбъекта <> Неопределено И Версия <> Неопределено Тогда
		Результат.Вставить("ПолеПоиска", Формат(НомерОбъекта, "ЧН=0; ЧВН=; ЧГ=") + "_" + Формат(Версия, "ЧН=0; ЧВН=; ЧГ="));
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Описывает объект-структуру информации об объекте PDF.
//
// Возвращаемое значение:
//	Структура
//
Функция ОписаниеОбъектаДокумента(НомерОбъекта = Неопределено, Версия = Неопределено)
	
	Результат = Новый Структура;
	Результат.Вставить("ТипОбъекта", "Объект");
	Результат.Вставить("Ссылка", ДанныеСсылкиОбъекта(НомерОбъекта, Версия));
	Результат.Вставить("Поток", Ложь); // предварительное извлечение
	Результат.Вставить("Описание", Неопределено); // заголовок раздела
	Результат.Вставить("Позиция", Неопределено);
	Результат.Вставить("ТипДанных", "");
	Результат.Вставить("Инициализирован", Ложь);
	Результат.Вставить("Содержимое", Неопределено); // подготовленное значение узла: текст, таблица шрифта
	
	Возврат Результат;
	
КонецФункции

// Описывает объект-структуру со строко подписью
//
// Возвращаемое значение:
//	Структура
//
Функция ОбъектПодписи()
	
	Результат = Новый Структура;
	Результат.Вставить("УказательДанных", Новый Массив);
	Результат.Вставить("Алгоритм", "");
	Результат.Вставить("Подпись", Неопределено);
	
	Возврат Результат;
	
КонецФункции

#КонецОбласти

#Область РазборОписания

// Проверяет возможность получения следующего символа строки.
// Осуществляется защита от зацикливания.
//
// Возвращаемое значение:
//	Булево
//
Функция КонтрольЦикла(ОбъектПарсинга, Успешно, ЧислоСимволов = 1)
	
	ОбъектПарсинга.Позиция = ОбъектПарсинга.Позиция + ЧислоСимволов;
	
	Возврат Успешно И ОбъектПарсинга.Длина >= ОбъектПарсинга.Позиция;
	
КонецФункции

// Проверяет возможность перехода к следующему символу строки.
// При необходимости вызывает исключение.
//
// Возвращаемое значение:
//	Булево
//
Функция КонтрольДлины(ОбъектПарсинга, Прерывать = Ложь)
	
	Результат = ОбъектПарсинга.Длина >= ОбъектПарсинга.Позиция;
	
	Если Прерывать И НЕ Результат Тогда
		ВызватьИсключение "Превышение длины";
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Проверяет переданную строку на вхождение в набор спецсимволов PDF.
//
// Возвращаемое значение:
//	Булево
//
Функция ЭтоСпецСимвол(ОбъектПарсинга, ТекущийСимвол)
	
	Возврат СтрНайти(ОбъектПарсинга.Владелец.НаборСимволов.СпецСимволы, ТекущийСимвол) > 0;
	
КонецФункции

// Проверяет переданную строку равенство пробельным символов PDF.
// Актуально для массивов, служебных переводов строк, чтобы исключить его из результата анализа.
//
// Возвращаемое значение:
//	Булево
//
Функция ЭтоПробельныйСимвол(НаборСимволов, ТекущийСимвол)
	
	Возврат СтрНайти(НаборСимволов.СимволыПробела, ТекущийСимвол) > 0 ИЛИ ТекущийСимвол = "";
	
КонецФункции

// Смещает позицию в объекте-парсера.
//
// Возвращаемое значение:
//	Булево
//
Функция СледующаяПозицияСодержимого(ОбъектПарсинга, Шаг = 1, Контроль = Истина)
	
	ОбъектПарсинга.Позиция = ОбъектПарсинга.Позиция + Шаг;
	
	Результат = КонтрольДлины(ОбъектПарсинга, Контроль);
	
	Возврат Результат;
	
КонецФункции

// Получает содержимое строки начиная с текущей позиции в объекте-парсера.
//
// Возвращаемое значение:
//	Строка
//
Функция ЗначениеСодержимого(ОбъектПарсинга, ЧислоСимволов = 1)
	
	Возврат  Сред(ОбъектПарсинга.Содержимое, ОбъектПарсинга.Позиция, ЧислоСимволов);
	
КонецФункции

// Извлекает c текущей позиции объекта-парсера именнованое значение по стандарту PDF.
// Имена начинаются с символа "/".
//
// Возвращаемое значение:
//	Строка
//
Функция ПолучитьЗначениеТипаИмя(ОбъектПарсинга)
	
	Результат = "";
	
	СледующаяПозицияСодержимого(ОбъектПарсинга, 1, Ложь);
	НаборСимволов = ОбъектПарсинга.Владелец.НаборСимволов;
	Успешно = Истина;
	
	Пока Успешно Цикл
		ПервыйСимвол = ЗначениеСодержимого(ОбъектПарсинга);
		
		Если НаборСимволов.КодСимвола = ПервыйСимвол Тогда
			СледующаяПозицияСодержимого(ОбъектПарсинга);
			ДваСимвола = ЗначениеСодержимого(ОбъектПарсинга, 2);
			ПервыйСимвол = ПолучитьСтрокуИзHEX(ОбъектПарсинга.Владелец.Кодировка, ДваСимвола);
			СледующаяПозицияСодержимого(ОбъектПарсинга, 2);
			
		ИначеЕсли ЭтоСпецСимвол(ОбъектПарсинга, ПервыйСимвол)
			ИЛИ ЭтоПробельныйСимвол(НаборСимволов, ПервыйСимвол) Тогда
			Прервать;
			
		КонецЕсли;
		
		Результат = Результат + ПервыйСимвол;
		Успешно = КонтрольЦикла(ОбъектПарсинга, Успешно);
		
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

// Дополняет словарь PDF очередным значением начиная с текущей позиции объекта-парсера.
//
Процедура ДополнитьСловарьЗначением(ОбъектПарсинга, ТекущийСловарь, ИмяЗначение, ПредставлениеЗначения)
	
	Если ЗначениеЗаполнено(ПредставлениеЗначения) Тогда
		НовыйПарсинг = ОбъектДляПарсинга(ОбъектПарсинга.Владелец, ПредставлениеЗначения);
		ТекущийСловарь.Вставить(ИмяЗначение, ПолучитьЗначениеОбъекта(НовыйПарсинг));
	КонецЕсли;
	
	ПредставлениеЗначения = "";
	
КонецПроцедуры

// Формирует словарь c текущей позиции объекта-парсера по стандарту PDF.
// Словарь заключен в операторные скобки: "<<" и ">>".
//
// Возвращаемое значение:
//	Соответствие
//
Функция ПолучитьЗначениеТипаСловарь(ОбъектПарсинга)
	
	Результат = Новый Соответствие;
	
	СледующаяПозицияСодержимого(ОбъектПарсинга, 2, Ложь);
	НаборСимволов = ОбъектПарсинга.Владелец.НаборСимволов;
	Успешно = Истина;
	ПредставлениеЗначения = "";
	ТекущееИмя = "";
	НовоеЗначение = Ложь;
	Пропустить = Ложь;
	
	Пока Успешно Цикл
		ПервыйСимвол = ЗначениеСодержимого(ОбъектПарсинга);
		ДваСимвола = ЗначениеСодержимого(ОбъектПарсинга, 2);
		ЧислоСимволов = 1;
		
		Если ДваСимвола = НаборСимволов.ОкончаниеСловаря Тогда
			Успешно = Ложь;
			ДополнитьСловарьЗначением(ОбъектПарсинга, Результат, ТекущееИмя, ПредставлениеЗначения);
			ЧислоСимволов = 2;
		ИначеЕсли ПервыйСимвол = НаборСимволов.Имя Тогда
			Если НовоеЗначение И ЗначениеЗаполнено(ПредставлениеЗначения) Тогда
				ДополнитьСловарьЗначением(ОбъектПарсинга, Результат, ТекущееИмя, ПредставлениеЗначения);
				НовоеЗначение = Ложь;
			ИначеЕсли НовоеЗначение Тогда
				Результат.Вставить(ТекущееИмя, ПолучитьЗначениеТипаИмя(ОбъектПарсинга));
				НовоеЗначение = Ложь;
				ЧислоСимволов = 0;
			Иначе
				НовоеЗначение = Истина;
				ЧислоСимволов = 0;
				ТекущееИмя = ПолучитьЗначениеТипаИмя(ОбъектПарсинга);
				Результат.Вставить(ТекущееИмя, Истина);
			КонецЕсли;
		ИначеЕсли ЭтоПробельныйСимвол(НаборСимволов, ПервыйСимвол) И НовоеЗначение Тогда
			НовоеЗначение = Истина;
		ИначеЕсли НЕ ЭтоСпецСимвол(ОбъектПарсинга, ПервыйСимвол) И НЕ НовоеЗначение Тогда
			ПредставлениеЗначения = ПредставлениеЗначения + ПервыйСимвол;
		Иначе
			ПолученноеЗначение = ПолучитьЗначениеОбъекта(ОбъектПарсинга, Пропустить);
			Если НЕ Пропустить Тогда
				Результат.Вставить(ТекущееИмя, ПолученноеЗначение);
				НовоеЗначение = Ложь;
			КонецЕсли;
			ЧислоСимволов = 0;
		КонецЕсли;
		
		Успешно = КонтрольЦикла(ОбъектПарсинга, Успешно, ЧислоСимволов);
		
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

// Дополняет массив очередными значениями.
//
Процедура ДополнитьМассивЗначениями(ОбъектПарсинга, ТекущийМассив, НаборЗначений)
	
	Если ПустаяСтрока(НаборЗначений) Тогда
		Возврат;
	КонецЕсли;
	
	НаборСимволов = ОбъектПарсинга.Владелец.НаборСимволов;
	ВесьМассив = СтрЗаменить(СокрЛП(НаборЗначений), НаборСимволов.ПереводСтроки, " ");
	ВесьМассив = СтрЗаменить(ВесьМассив, НаборСимволов.Пробел + НаборСимволов.Пробел, " ");
	ВесьМассив = СтрРазделить(ВесьМассив, " ", Ложь);
	ВсегоЭлементов = ВесьМассив.Количество() - 1;
	ПозицияВставки = ТекущийМассив.Количество();
	
	Пока ВсегоЭлементов >= 0 Цикл
		ПервыйЭлемент = СокрЛП(ВесьМассив[ВсегоЭлементов]);
		Если НаборСимволов.Ссылка = ПервыйЭлемент И ВсегоЭлементов > 1 Тогда
			ПредставлениеОбъекта = ВесьМассив[ВсегоЭлементов - 2] + " " + ВесьМассив[ВсегоЭлементов - 1] + " " + ПервыйЭлемент;
			ВсегоЭлементов = ВсегоЭлементов - 3;
		Иначе
			ПредставлениеОбъекта = ПервыйЭлемент;
			ВсегоЭлементов = ВсегоЭлементов - 1;
		КонецЕсли;
		НовыйПарсинг = ОбъектДляПарсинга(ОбъектПарсинга.Владелец, ПредставлениеОбъекта);
		НовоеЗначение = ПолучитьЗначениеОбъекта(НовыйПарсинг);
		ТекущийМассив.Вставить(ПозицияВставки, НовоеЗначение);
	КонецЦикла;
	
КонецПроцедуры

// Формирует массив c текущей позиции объекта-парсера по стандарту PDF.
// Словарь заключен в операторные скобки: "[" и "]".
//
// Возвращаемое значение:
//	Соответствие
//
Функция ПолучитьЗначениеТипаМассив(ОбъектПарсинга)
	
	СледующаяПозицияСодержимого(ОбъектПарсинга, 1, Ложь);
	НаборСимволов = ОбъектПарсинга.Владелец.НаборСимволов;
	Результат = Новый Массив;
	
	Успешно = Истина;
	ТекущееЗначение = "";
	Пропустить = Ложь;
	
	Пока Успешно Цикл
		
		ПервыйСимвол = ЗначениеСодержимого(ОбъектПарсинга);
		ЧислоСимволов = 1;
		
		Если ПервыйСимвол = НаборСимволов.ОкончаниеМассива Тогда
			Успешно = Ложь;
			ДополнитьМассивЗначениями(ОбъектПарсинга, Результат, ТекущееЗначение);
			
		ИначеЕсли НЕ ЭтоСпецСимвол(ОбъектПарсинга, ПервыйСимвол) Тогда
			ТекущееЗначение = ТекущееЗначение + ПервыйСимвол;
			
		Иначе
			ДополнитьМассивЗначениями(ОбъектПарсинга, Результат, ТекущееЗначение);
			ТекущееЗначение = "";
			ПолученноеЗначение = ПолучитьЗначениеОбъекта(ОбъектПарсинга, Пропустить);
			Если НЕ Пропустить Тогда
				Результат.Добавить(ПолученноеЗначение);
			КонецЕсли;
			ЧислоСимволов = 0;
			
		КонецЕсли;
		
		Успешно = КонтрольЦикла(ОбъектПарсинга, Успешно, ЧислоСимволов);
		
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

// Формирует строку с комментарием от текущей позиции объекта-парсера по стандарту PDF.
// Начинается "%" и до конца строки
//
// Возвращаемое значение:
//	Строка
//
Функция ПолучитьЗначениеТипаКомментарий(ОбъектПарсинга)
	
	Результат = "";
	Успешно = Истина;
	СледующаяПозицияСодержимого(ОбъектПарсинга, 1, Ложь);
	НаборСимволов = ОбъектПарсинга.Владелец.НаборСимволов;
	
	Пока Успешно Цикл
		ПервыйСимвол = ЗначениеСодержимого(ОбъектПарсинга);
		Если ПервыйСимвол = НаборСимволов.ПереводСтроки Тогда
			Успешно = Ложь;
		Иначе
			Результат = Результат + ПервыйСимвол;
		КонецЕсли;
		Успешно = КонтрольЦикла(ОбъектПарсинга, Успешно);
	КонецЦикла;
	
	ОбъектПарсинга.Комментарий = ОбъектПарсинга.Комментарий + НаборСимволов.ПереводСтроки + Результат;
	ОбъектПарсинга.Комментарий = СокрЛП(ОбъектПарсинга.Комментарий);
	
	Возврат Результат;
	
КонецФункции

// Формирует строку текущей позиции объекта-парсера по стандарту PDF.
// Строка заключена в операторные скобки: "(" и ")".
//
// Возвращаемое значение:
//	Строка
//
Функция ПолучитьЗначениеТипаСтрока(ОбъектПарсинга, УскоритьПолучение = Ложь)
	
	Экраны = ОбъектПарсинга.Владелец.ЭкраныСимволов;
	СледующаяПозицияСодержимого(ОбъектПарсинга, 1, Ложь);
	НаборСимволов = ОбъектПарсинга.Владелец.НаборСимволов;
	Результат = "";
	
	Успешно = Истина;
	
	Пока Успешно Цикл
		
		ЧислоСимволов = 1;
		ПервыйСимвол = ЗначениеСодержимого(ОбъектПарсинга);
		
		Если ПервыйСимвол = НаборСимволов.НачалоСтроки Тогда
			ЧислоСимволов = 0;
			Результат = Результат + ПолучитьЗначениеТипаСтрока(ОбъектПарсинга);
				
		ИначеЕсли ПервыйСимвол = НаборСимволов.ОкончаниеСтроки Тогда
			Успешно = Ложь;
			
		ИначеЕсли ПервыйСимвол = НаборСимволов.Экран Тогда
			ДваСимвола = ЗначениеСодержимого(ОбъектПарсинга, 2);
			СимволыЧисла = Сред(ЗначениеСодержимого(ОбъектПарсинга, 4), 2);
			ЗаменаСимвола = Экраны[ДваСимвола];
			
			Если ЗаменаСимвола <> Неопределено Тогда
				СледующаяПозицияСодержимого(ОбъектПарсинга);
				Результат = Результат + ЗаменаСимвола;
				
			ИначеЕсли УскоритьПолучение ИЛИ ЭтоЧисло(Сред(СимволыЧисла, 1, 3), Истина, Истина) Тогда
				СледующаяПозицияСодержимого(ОбъектПарсинга, 3);
				Результат = Результат + ПолучитьСимволПоВосьмеричномуКоду(СимволыЧисла, 3);
				
			ИначеЕсли ЭтоЧисло(Сред(СимволыЧисла, 1, 2), Истина, Истина) Тогда
				СледующаяПозицияСодержимого(ОбъектПарсинга, 2);
				Результат = Результат + ПолучитьСимволПоВосьмеричномуКоду(СимволыЧисла, 2);
				
			ИначеЕсли ЭтоЧисло(Сред(СимволыЧисла, 1, 1), Истина, Истина) Тогда
				СледующаяПозицияСодержимого(ОбъектПарсинга, 1);
				Результат = Результат + ПолучитьСимволПоВосьмеричномуКоду(СимволыЧисла, 1);
				
			КонецЕсли;
			
		Иначе
			Результат = Результат + ПервыйСимвол;
			
		КонецЕсли;
		
		Успешно = КонтрольЦикла(ОбъектПарсинга, Успешно, ЧислоСимволов);
		
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

// Формирует строку их HEX представления от текущей позиции объекта-парсера по стандарту PDF.
// Строка заключена в операторные скобки: "<" и ">".
//
// Возвращаемое значение:
//	Строка
//
Функция ПолучитьЗначениеТипаHEXСтрока(ОбъектПарсинга)
	
	СледующаяПозицияСодержимого(ОбъектПарсинга, 1, Ложь);
	НаборСимволов = ОбъектПарсинга.Владелец.НаборСимволов;
	ПредставлениеСтроки = "";
	Результат = "";
	Успешно = Истина;
	
	// ускорение для очень длиных строк
	ПозицияОкончания = СтрНайти(ОбъектПарсинга.Содержимое, НаборСимволов.ОкончаниеHEXСтроки, , ОбъектПарсинга.Позиция);
	Если ПозицияОкончания > 0 Тогда
		ПредставлениеСтроки = ЗначениеСодержимого(ОбъектПарсинга, ПозицияОкончания - ОбъектПарсинга.Позиция);
		КонтрольЦикла(ОбъектПарсинга, Успешно, ПозицияОкончания - ОбъектПарсинга.Позиция + 1);
		ПредставлениеСтроки = СтрЗаменить(ПредставлениеСтроки, НаборСимволов.Пробел, "");
		ПредставлениеСтроки = СтрЗаменить(ПредставлениеСтроки, НаборСимволов.Табуляция, "");
		ПредставлениеСтроки = СтрЗаменить(ПредставлениеСтроки, НаборСимволов.ПереводСтроки, "");
		ПредставлениеСтроки = СтрЗаменить(ПредставлениеСтроки, НаборСимволов.ВозвратКаретки, "");
		ПредставлениеСтроки = СтрЗаменить(ПредставлениеСтроки, НаборСимволов.ПереводФормы, "");
	Иначе
		КонтрольЦикла(ОбъектПарсинга, Успешно, ОбъектПарсинга.Позиция + 1);
	КонецЕсли;
	
	Результат = ПредставлениеСтроки;
	Если ЗначениеЗаполнено(ПредставлениеСтроки) И НЕ ОбъектПарсинга.Владелец.НеобрабатывватьHEXСтроки Тогда
		Результат = ПолучитьСтрокуИзHEX(ОбъектПарсинга.Владелец.Кодировка, ПредставлениеСтроки);
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Формирует строку выражения от текущей позиции объекта-парсера по стандарту PDF.
// Строка заключена в операторные скобки: "{" и "}".
//
// Возвращаемое значение:
//	Строка
//
Функция ПолучитьЗначениеТипаВыражение(ОбъектПарсинга)
	
	СледующаяПозицияСодержимого(ОбъектПарсинга, 1, Ложь);
	НаборСимволов = ОбъектПарсинга.Владелец.НаборСимволов;
	Результат = "";
	
	Успешно = Истина;
	
	Пока Успешно Цикл
		ПервыйСимвол = ЗначениеСодержимого(ОбъектПарсинга);
		
		Если ПервыйСимвол = НаборСимволов.ОкончаниеВыражения Тогда
			Успешно = Ложь;
		Иначе
			Результат = Результат + ПервыйСимвол;
		КонецЕсли;
		
		Успешно = КонтрольЦикла(ОбъектПарсинга, Успешно);
		
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

// Формирует объект-ссылку от текущей позиции объекта-парсера по стандарту PDF.
// Строка типа: "10 0 R".
//
// Возвращаемое значение:
//	Строка
//
Функция ПолучитьЗначениеТипаСсылка(ОбъектПарсинга, ТекущееЗначение)
	
	Результат = ДанныеСсылкиОбъекта();
	
	ВесьМассив = СтрРазделить(ТекущееЗначение, " ", Ложь);
	
	Если ВесьМассив.Количество() > 1 Тогда
		Результат = ДанныеСсылкиОбъекта(ВесьМассив[0], ВесьМассив[1]);
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Обобщенная фунция для полученя значений простого типа.
// Типы: булево, null, ссылка, число, содержимое строки
//
// Возвращаемое значение:
//	Строка
//
Функция ПолучитьЗначениеТипаПростой(ОбъектПарсинга, Содержимое)
	
	ТекущееЗначение = Содержимое;
	НаборСимволов = ОбъектПарсинга.Владелец.НаборСимволов;
	
	Если ТекущееЗначение = "null" Тогда
		Результат = Неопределено;
	ИначеЕсли ТекущееЗначение = "false" Тогда
		Результат = Ложь;
	ИначеЕсли ТекущееЗначение = "true" Тогда
		Результат = Истина;
	ИначеЕсли Прав(ТекущееЗначение, 2) = НаборСимволов.Пробел + НаборСимволов.Ссылка 
		ИЛИ Прав(ТекущееЗначение, 3) = НаборСимволов.Пробел + НаборСимволов.Ссылка + НаборСимволов.Пробел Тогда
		Результат = ПолучитьЗначениеТипаСсылка(ОбъектПарсинга, ТекущееЗначение);
	ИначеЕсли ЭтоЧисло(ТекущееЗначение) Тогда
		Результат = Число(ТекущееЗначение);
	Иначе
		Результат = ТекущееЗначение;
	КонецЕсли; 
	
	Возврат Результат;
	
КонецФункции

// Цикл для обработки объекта-парсера и получения простых типов.
//
// Возвращаемое значение:
//	Произвольный
//
Функция ПолучитьЗначениеСледующее(ОбъектПарсинга)
	
	Результат = "";
	НаборСимволов = ОбъектПарсинга.Владелец.НаборСимволов;
	Успешно = Истина;
	ЧислоСимволов = 1;
	
	Пока Успешно Цикл
		ПервыйСимвол = ЗначениеСодержимого(ОбъектПарсинга);
		Если ЭтоСпецСимвол(ОбъектПарсинга, ПервыйСимвол) Тогда
			Успешно = Ложь;
			ЧислоСимволов = 0;
		Иначе
			Результат = Результат + ПервыйСимвол;
		КонецЕсли;
		Успешно = КонтрольЦикла(ОбъектПарсинга, Успешно, ЧислоСимволов);
	КонецЦикла;
	
	Если Прав(Результат, 1) = НаборСимволов.ПереводСтроки Тогда
		Результат = Лев(Результат, СтрДлина(Результат) - 1);
	КонецЕсли;
	
	Результат = ПолучитьЗначениеТипаПростой(ОбъектПарсинга, Результат);
	
	Возврат Результат;
	
КонецФункции

// Точка входа для начала обработки объекта-парсера и получения итогового значения.
//
// Возвращаемое значение:
//	Произвольный
//
Функция ПолучитьЗначениеОбъекта(ОбъектПарсинга, Пропустить = Ложь)
	
	Пропустить = Ложь;
	Результат = Неопределено;
	
	ПервыйСимвол = ЗначениеСодержимого(ОбъектПарсинга);
	ДваСимвола = ЗначениеСодержимого(ОбъектПарсинга, 2);
	НаборСимволов = ОбъектПарсинга.Владелец.НаборСимволов;
	
	Если НаборСимволов.НачалоСловаря = ДваСимвола Тогда
		Результат = ПолучитьЗначениеТипаСловарь(ОбъектПарсинга);
	ИначеЕсли НаборСимволов.НачалоМассива = ПервыйСимвол Тогда
		Результат = ПолучитьЗначениеТипаМассив(ОбъектПарсинга);
	ИначеЕсли НаборСимволов.Имя = ПервыйСимвол Тогда
		Результат = ПолучитьЗначениеТипаИмя(ОбъектПарсинга);
	ИначеЕсли НаборСимволов.Комментарий = ПервыйСимвол Тогда
		Пропустить = Истина;
		Результат = ПолучитьЗначениеТипаКомментарий(ОбъектПарсинга); // игнорируем комментарий
	ИначеЕсли НаборСимволов.НачалоСтроки = ПервыйСимвол Тогда
		Результат = ПолучитьЗначениеТипаСтрока(ОбъектПарсинга);
	ИначеЕсли НаборСимволов.НачалоHEXСтроки = ПервыйСимвол Тогда
		Результат = ПолучитьЗначениеТипаHEXСтрока(ОбъектПарсинга);
	ИначеЕсли НаборСимволов.НачалоВыражения = ПервыйСимвол Тогда
		Результат = ПолучитьЗначениеТипаВыражение(ОбъектПарсинга);
	Иначе
		Результат = ПолучитьЗначениеСледующее(ОбъектПарсинга);
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

#КонецОбласти

#Область РазборФайла

// Смещает позицию на указанную в потоке данных.
//
Процедура ПерейтиКПозицииДанных(ОбъектДокумента, НачалоПозиции)
	
	ТекущийПоток = ОбъектДокумента.ПотокДанных;
	ТекущаяПозиция = ТекущийПоток.ТекущаяПозиция();
	
	ТекущийПоток.Перейти(НачалоПозиции - ТекущаяПозиция, ПозицияВПотоке.Текущая);
	
КонецПроцедуры

// Смещает позицию на указанное количество байт от текущей.
//
Процедура СдвинутьПозициюДанных(ОбъектДокумента, КоличествоБайт)
	
	ТекущийПоток = ОбъектДокумента.ПотокДанных;
	ТекущаяПозиция = ТекущийПоток.ТекущаяПозиция();
	
	ТекущийПоток.Перейти(КоличествоБайт, ПозицияВПотоке.Текущая);
	
КонецПроцедуры

// Получает буфер двоичных данных из потока данных.
//
// Возвращаемое значение:
//	БуферДвоичныхДанных
//
Функция ПрочитатьДанныеПотока(ОбъектДокумента, КоличествоБайт, НачалоПозиции = Неопределено, КакТекст = Ложь)
	
	Результат = Новый БуферДвоичныхДанных(КоличествоБайт);
	Если НачалоПозиции <> Неопределено Тогда
		ПерейтиКПозицииДанных(ОбъектДокумента, НачалоПозиции);
	КонецЕсли;
	
	ТекущийПоток = ОбъектДокумента.ПотокДанных;
	ТекущийПоток.Прочитать(Результат, 0, КоличествоБайт);
	
	Если КакТекст Тогда
		Результат = ПолучитьСтрокуИзБуфераДвоичныхДанных(Результат, ОбъектДокумента.Кодировка);
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Получает очередую строку из потока данных, при необходимости позицию в нем оставляет преждней.
//
// Возвращаемое значение:
//	Строка
//
Функция ПолучитьСледующуюСтроку(ОбъектДокумента, ПредварительноеЧтение = Ложь, СдвигСтроки = 0)
	
	ТекущийПоток = ОбъектДокумента.ПотокДанных;
	ТекущаяПозиция = ТекущийПоток.ТекущаяПозиция();
	
	Если ТекущийПоток.Размер() <= ТекущаяПозиция Тогда
		ВызватьИсключение "Превышен размер файла"; 
	КонецЕсли;
	
	ЧтениеДанных = Новый ЧтениеДанных(ТекущийПоток, ОбъектДокумента.Кодировка);
	Результат = ЧтениеДанных.ПрочитатьСтроку();
	ЧтениеДанных.Закрыть();
	
	ДлинаСтроки = СтрДлина(Результат);
	Если ДлинаСтроки > 0 Тогда
		
		СдвигСтроки = ТекущийПоток.ТекущаяПозиция() - ТекущаяПозиция;
		
		Если ПредварительноеЧтение Тогда
			 СдвинутьПозициюДанных(ОбъектДокумента, - ДлинаСтроки - 1);
		КонецЕсли;
		
		Если Прав(Результат, 1) = ОбъектДокумента.НаборСимволов.Пробел Тогда
			Результат = Лев(Результат, ДлинаСтроки - 1);
		КонецЕсли;
		
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Получает позицию с которой начинается описание структуры объектов в файле.
//
// Возвращаемое значение:
//	Число
//
Функция ПолучитьЗначениеРазделаСмещение(ОбъектДокумента)
	
	Смещение = 0;
	ТекущаяСтрока = ПолучитьСледующуюСтроку(ОбъектДокумента);
	Если ЭтоЧисло(ТекущаяСтрока, Истина, Истина) Тогда
		Смещение = Число(ТекущаяСтрока);
	КонецЕсли;
	
	Если Смещение > 0 Тогда
		ПерейтиКПозицииДанных(ОбъектДокумента, Смещение);
		ПрочитатьРазделДокумента(ОбъектДокумента);
	КонецЕсли;
	
	Возврат Смещение;
	
КонецФункции

// Получает итоговую строку, формирование заканчивается при наличие закрывающего тега.
//
// Возвращаемое значение:
//	Строка
//
Функция СобратьСтроку(ОбъектДокумента, Ограничитель)
	
	Результат = "";
	Успешно = Истина;
	
	Пока Успешно Цикл
		ТекущаяСтрока = ПолучитьСледующуюСтроку(ОбъектДокумента);
		Успешно = СтрНайти(ТекущаяСтрока, Ограничитель) = 0;
		Если Успешно Тогда
			Результат = Результат + ТекущаяСтрока + ОбъектДокумента.НаборСимволов.ПереводСтроки;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

// Формирует описание объекта для прицепа (начинается с тега trailer).
// Обычно это начальный объект в PDF - точка входа для начала парсинга.
//
// Возвращаемое значение:
//	Соответствие
//
Функция ПолучитьЗначениеРазделаПрицепа(ОбъектДокумента, ТекущаяСтрока)
	
	НаборСимволов = ОбъектДокумента.НаборСимволов;
	
	ТекущаяСтрока = СтрЗаменить(ТекущаяСтрока, НаборСимволов.Прицеп, "");
	Если НЕ ПустаяСтрока(ТекущаяСтрока) Тогда
		ТекущаяСтрока = ТекущаяСтрока + НаборСимволов.ПереводСтроки;
	Иначе
		ТекущаяСтрока = "";
	КонецЕсли;
	
	ТекущаяСтрока = ТекущаяСтрока + СобратьСтроку(ОбъектДокумента, НаборСимволов.ПозицияОписания);
	НовыйПарсинг = ОбъектДляПарсинга(ОбъектДокумента, СокрЛП(ТекущаяСтрока));
	
	ДанныеРаздела = ПолучитьЗначениеОбъекта(НовыйПарсинг);
	Если ТипЗнч(ДанныеРаздела) = Тип("Соответствие") Тогда
		Если ОбъектДокумента.НачальныйРаздел = Неопределено Тогда
			ОбъектДокумента.НачальныйРаздел = ДанныеРаздела;
		КонецЕсли;
		
		Если ДанныеРаздела["Prev"] <> Неопределено Тогда
			ПерейтиКПозицииДанных(ОбъектДокумента, ДанныеРаздела["Prev"]);
			ПрочитатьРазделДокумента(ОбъектДокумента);
		КонецЕсли;
	КонецЕсли;
	
	Возврат ДанныеРаздела;
	
КонецФункции

// Формирует реестр объектов PDF (пустых), заключенные в stream объекта описателя.
//
// Возвращаемое значение:
//	Соответствие
//
Функция ПолучитьЗначениеРазделаСсылокПотока(ОбъектДокумента, ОбъектОписания)
	
	Результат = Новый Соответствие;
	ТекстСсылок = ПолучитьСодержимоеУзла(ОбъектДокумента, ОбъектОписания.Ссылка);
	ДанныеСсылок = ПолучитьБуферДвоичныхДанныхИзСтроки(ТекстСсылок, ОбъектДокумента.Кодировка);
	ИндексСсылок = ПолучитьЗначение(ОбъектОписания.Описание, "Index", Новый Массив);
	КолонкиПотока = ПолучитьЗначение(ОбъектОписания.Описание, "W", Новый Массив);
	
	Если ИндексСсылок.Количество() > 0 Тогда
		НомерОбъекта = ИндексСсылок[0];
	Иначе
		НомерОбъекта = 0;
	КонецЕсли;
	
	СвободныйОбъект = Неопределено;
	МассивДобавки = Новый Массив;
	
	Счетчик = 0;
	СчетчикОбъектов = 0;
	Пока Счетчик < ДанныеСсылок.Размер Цикл
		
		ДанныеРаздела = Новый Массив; 
		Для СчетчикКолонок = 1 По КолонкиПотока.Количество() Цикл
			ДлинаКолонки = КолонкиПотока[СчетчикКолонок - 1];
			Если ДлинаКолонки > 0 Тогда
				ДанныеРаздела.Добавить(ПолучитьЧислоИзБуфера(ДанныеСсылок.ПолучитьСрез(Счетчик, ДлинаКолонки), ПорядокБайтов.BigEndian));
			ИначеЕсли СчетчикКолонок = 1 Тогда
				ДанныеРаздела.Добавить(1);
			ИначеЕсли СчетчикКолонок = 3 Тогда
				ДанныеРаздела.Добавить(0);
			КонецЕсли;
			Счетчик = Счетчик + ДлинаКолонки;
		КонецЦикла;
		
		Если ДанныеРаздела[0] = 2 Тогда // получить в ObjStm
			МассивДобавки.Добавить(Новый Структура("Объект, Реестр, Индекс", НомерОбъекта + СчетчикОбъектов, ДанныеРаздела[1], ДанныеРаздела[2]));
		ИначеЕсли ДанныеРаздела[0] = 1 Тогда // позиция в файле
			НовыйОбъект = ОписаниеОбъектаДокумента(НомерОбъекта + СчетчикОбъектов, ДанныеРаздела[2]);
			НовыйОбъект.Позиция = ДанныеРаздела[1];
			Результат.Вставить(НовыйОбъект.Ссылка.ПолеПоиска, НовыйОбъект);
		ИначеЕсли ДанныеРаздела[0] = 0 Тогда
			СвободныйОбъект = ДанныеРаздела[1];
		КонецЕсли;
			
		СчетчикОбъектов = СчетчикОбъектов + 1;
	КонецЦикла;
	
	ОбщегоНазначенияКлиентСервер.ДополнитьСоответствие(ОбъектДокумента.Объекты, Результат, Истина);
	
	РеестрОбъектов = Новый Соответствие;
	Для Каждого СтрокаМассива Из МассивДобавки Цикл
		
		ТекущийРеестр = РеестрОбъектов[СтрокаМассива.Реестр];
		Если ТекущийРеестр = Неопределено Тогда
			ТекущийРеестр = Новый Соответствие;
			Ссылкабъекта = ДанныеСсылкиОбъекта(СтрокаМассива.Реестр, 0);
			ОписаниеОбъекта = ПолучитьОбъектПоСсылке(ОбъектДокумента, Ссылкабъекта);
			СодержимоеУзла = ПолучитьСодержимоеУзла(ОбъектДокумента, Ссылкабъекта);
			
			Если СодержимоеУзла <> Неопределено Тогда
				НачальнаяПозиция = ПолучитьЗначение(ОписаниеОбъекта.Описание, "First", 1);
				ВсегоЭлементов = ПолучитьЗначение(ОписаниеОбъекта.Описание, "N", 0);
				Если НачальнаяПозиция > 1 Тогда
					НовыйПарсинг = ОбъектДляПарсинга(ОбъектДокумента, "[" + Сред(СодержимоеУзла, 1, НачальнаяПозиция - 1) + "]");
					МассивОбъектов = ПолучитьЗначениеТипаМассив(НовыйПарсинг);
					
					ВсегоЭлементов = ВсегоЭлементов - 1;
					ВтораяПозиция = СтрДлина(СодержимоеУзла);
					Пока ВсегоЭлементов >= 0 Цикл
						НомерОбъекта = МассивОбъектов[ВсегоЭлементов * 2];
						ПерваяПозиция = МассивОбъектов[ВсегоЭлементов * 2 + 1] + НачальнаяПозиция + 1;
						ТекущийРеестр.Вставить(НомерОбъекта, Сред(СодержимоеУзла, ПерваяПозиция, ВтораяПозиция - ПерваяПозиция + 1));
						ВтораяПозиция = ПерваяПозиция - 1;
						ВсегоЭлементов = ВсегоЭлементов - 1;
					КонецЦикла;
					
				КонецЕсли;
			
				РеестрОбъектов.Вставить(СтрокаМассива.Реестр, ТекущийРеестр)
				
			КонецЕсли;
			
		КонецЕсли;
		
		ТекущийОбъект = ТекущийРеестр[СтрокаМассива.Объект];
		Ссылкабъекта = ДанныеСсылкиОбъекта(СтрокаМассива.Объект, 0);
		
		НашлиОбъект = ПолучитьОбъектПоСсылке(ОбъектДокумента, Ссылкабъекта);
		Если НашлиОбъект = Неопределено Тогда
			НовыйОбъект = ОписаниеОбъектаДокумента(СтрокаМассива.Объект, 0);
			НовыйОбъект.Описание = ТекущийОбъект;
			Результат.Вставить(НовыйОбъект.Ссылка.ПолеПоиска, НовыйОбъект);
			ОбъектДокумента.Объекты.Вставить(НовыйОбъект.Ссылка.ПолеПоиска, НовыйОбъект);
		КонецЕсли;
		
	КонецЦикла;
	
	Если ОбъектДокумента.НачальныйРаздел = Неопределено Тогда
		ОбъектДокумента.НачальныйРаздел = ОбъектОписания.Описание;
	КонецЕсли;
	
	ПредыдующийОбъект = ПолучитьЗначение(ОбъектОписания.Описание, "Prev");
	Если ПредыдующийОбъект <> Неопределено Тогда
		ПерейтиКПозицииДанных(ОбъектДокумента, ПредыдующийОбъект);
		ПрочитатьРазделДокумента(ОбъектДокумента);
	КонецЕсли;
	
	ОтразитьСостояниеОперации(ОбъектДокумента, "ЧтениеРазделовПоток");
	
	Возврат Результат;
	
КонецФункции

// Дополнительная обработка разархиварованных данных.  apply_png_prdictor
// Иногда, кроме архирования используется PNG обработка данных.
//
// Возвращаемое значение:
//	БуферДвоичныхДанных
//
Функция ПреобразованиеPNG(ОбъектДокумента, АлгоритмСжатия, Цвет, Колонки, БитовыйКомпонент, ДанныеРаздела)
	
	Результат = ДанныеРаздела;
	
	Если БитовыйКомпонент <> 8 Тогда
		Возврат Результат;
	КонецЕсли;
	
	Байты = Цел((Цвет * Колонки * БитовыйКомпонент) / 8);
	Буфер = Новый БуферДвоичныхДанных(0);
	Строка0 = Новый БуферДвоичныхДанных(Колонки);
	
	Счетчик = 0;
	Пока Счетчик < ДанныеРаздела.Размер Цикл
		ТекущийБайт = ДанныеРаздела.Получить(Счетчик);
		Строка1 = ДанныеРаздела.ПолучитьСрез(Счетчик + 1, Байты);
		Строка2 = Новый БуферДвоичныхДанных(0);
		
		Если ТекущийБайт = 0 Тогда // PNG none
			Строка2 = Строка2.Соединить(Строка1);
			
		ИначеЕсли ТекущийБайт = 1 Тогда // PNG sub (UNTESTED)
			Врем = 0;
			Для СчетчикДанных = 0 По Строка1.Размер - 1 Цикл
				Врем = (Врем + Строка1.Получить(СчетчикДанных)) / 256; 
				Строка2 = Строка2.Соединить(ДвоичноеПредставлениеЧисла(Врем));
			КонецЦикла;
				
		ИначеЕсли ТекущийБайт = 2 Тогда // PNG up
			Для СчетчикДанных = 0 По Строка1.Размер - 1 Цикл
				Врем = (Строка0.Получить(СчетчикДанных) + Строка1.Получить(СчетчикДанных)) % 256; 
				Строка2 = Строка2.Соединить(ДвоичноеПредставлениеЧисла(Врем));
			КонецЦикла;
			
		ИначеЕсли ТекущийБайт = 3 Тогда // PNG average (UNISTED)
			Врем = 0;
			Для СчетчикДанных = 0 По Строка1.Размер - 1 Цикл
				Врем = (Врем + Строка0.Получить(СчетчикДанных) + Строка1.Получить(СчетчикДанных)) % 256; 
				Строка2 = Строка2.Соединить(ДвоичноеПредставлениеЧисла(Врем));
			КонецЦикла;
			
		Иначе // не поддерживается
			Возврат Результат;
			
		КонецЕсли;
		
		Счетчик = Счетчик + Байты + 1;
		Буфер = Буфер.Соединить(Строка2);
		Строка0 = Строка2;
		
	КонецЦикла;
	
	Возврат Буфер;
	
КонецФункции

// Формирует реестр объектов PDF (пустых), заключенные в теги: xref и trailer.
//
// Возвращаемое значение:
//	Соответствие
//
Функция ПолучитьЗначениеРазделаСсылок(ОбъектДокумента)
	
	Результат = Новый Соответствие;
	НаборСимволов = ОбъектДокумента.НаборСимволов;
	Успешно = Истина;
	Счетчик = 0;
	Всего = 0;
	
	Пока Успешно Цикл
		СдвигСтроки = 0;
		ТекущаяСтрока = ПолучитьСледующуюСтроку(ОбъектДокумента, , СдвигСтроки);
		
		Если ТекущаяСтрока = НаборСимволов.Прицеп Тогда
			ДанныеРаздела = Новый Массив;
		Иначе
			ДанныеРаздела = СтрРазделитьТипизировать(ТекущаяСтрока, " ", "Число");
		КонецЕсли;
		
		Если ДанныеРаздела.Количество() = 2 Тогда // описание подраздела
			Счетчик = 0;
			НомерОбъекта = ДанныеРаздела[0];
			Всего = ДанныеРаздела[1];
			
		ИначеЕсли ДанныеРаздела.Количество() = 3 И Счетчик < Всего Тогда // описание ссылки
			НовыйОбъект = ОписаниеОбъектаДокумента(НомерОбъекта + Счетчик, ДанныеРаздела[1]);
			Если ДанныеРаздела[2] = "f" Тогда
				НовыйОбъект.Позиция = ДанныеСсылкиОбъекта(ДанныеРаздела[0], ДанныеРаздела[1]);
			Иначе
				НовыйОбъект.Позиция = ДанныеРаздела[0];
			КонецЕсли;
			
			Результат.Вставить(НовыйОбъект.Ссылка.ПолеПоиска, НовыйОбъект);
			
			Счетчик = Счетчик + 1;
		Иначе
			Успешно = Ложь;
		КонецЕсли;
		
		Если НЕ Успешно Тогда
			ДлинаСтроки = СтрДлина(ТекущаяСтрока);
			Если ДлинаСтроки > 0 И СдвигСтроки > 0 Тогда
				СдвинутьПозициюДанных(ОбъектДокумента, - СдвигСтроки);
			КонецЕсли;
		КонецЕсли;

	КонецЦикла;
	
	ОбщегоНазначенияКлиентСервер.ДополнитьСоответствие(ОбъектДокумента.Объекты, Результат, Истина);
	
	ОтразитьСостояниеОперации(ОбъектДокумента, "ЧтениеРазделов");
	
	// проверим на прицеп
	ПрочитатьРазделДокумента(ОбъектДокумента);
	
	Возврат Результат
	
КонецФункции

// Готовит, обрабатывает и возврщает содержимое объекта на основе его описания.
//
// Возвращаемое значение:
//  Структура
//
Функция ПолучитьЗначениеРазделаОбъект(ОбъектДокумента, ТекущаяСтрока)
	
	Результат = Неопределено;
	
	НаборСимволов = ОбъектДокумента.НаборСимволов;
	ОписаниеСсылки = ПолучитьЗначениеТипаСсылка(ОбъектДокумента, ТекущаяСтрока);
	НашлиОбъект = ОбъектДокумента.Объекты[ОписаниеСсылки.ПолеПоиска];
	
	Если НашлиОбъект = Неопределено И ОбъектДокумента.НачальноеЧтение Тогда
		НашлиОбъект = ОписаниеОбъектаДокумента(ОписаниеСсылки.Номер, ОписаниеСсылки.Версия);
	ИначеЕсли НашлиОбъект = Неопределено Тогда
		Возврат Результат;
	КонецЕсли;
	
	Результат = НашлиОбъект;
	
	ОписаниеОбъекта = "";
	НачалоПотока = 0;
	Успешно = Истина;
	Пока Успешно Цикл
		ТекущаяСтрока = ПолучитьСледующуюСтроку(ОбъектДокумента);
		ПозицияОкончания = СтрНайти(ТекущаяСтрока, НаборСимволов.ОкончаниеОбъекта);
		Если ПозицияОкончания > 0 Тогда
			ОписаниеОбъекта = ОписаниеОбъекта + Лев(ТекущаяСтрока, ПозицияОкончания - 1) + НаборСимволов.ПереводСтроки;
			Успешно = Ложь;
		ИначеЕсли СтрНайти(ТекущаяСтрока, НаборСимволов.НачалоПотока) > 0 Тогда
			Успешно = Ложь;
			Результат.Поток = Истина;
			НачалоПотока = ОбъектДокумента.ПотокДанных.ТекущаяПозиция();
			ОписаниеОбъекта = ОписаниеОбъекта + ТекущаяСтрока + НаборСимволов.ПереводСтроки;
		Иначе
			ОписаниеОбъекта = ОписаниеОбъекта + ТекущаяСтрока + НаборСимволов.ПереводСтроки;
		КонецЕсли;
	КонецЦикла;
	
	НовыйПарсинг = ОбъектДляПарсинга(ОбъектДокумента, ОписаниеОбъекта);
	Результат.Описание = ПолучитьЗначениеОбъекта(НовыйПарсинг);
	Результат.Инициализирован = Истина;
	
	Если ТипЗнч(Результат.Описание) = Тип("Соответствие") И Результат.Поток Тогда
		Результат.Описание.Вставить("Begin", НачалоПотока);
	КонецЕсли;
	
	Если ОбъектДокумента.НачальноеЧтение 
		И ПолучитьЗначение(Результат.Описание, "Type") = "XRef" Тогда
		ОбъектДокумента.Объекты.Вставить(ОписаниеСсылки.ПолеПоиска, Результат);
		ПолучитьЗначениеРазделаСсылокПотока(ОбъектДокумента, Результат);
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// По объекту-ссылке получаем описание объекта.
//
// Возвращаемое значение:
//  Структура
//
Функция ПолучитьЗначениеПоСсылке(ОбъектДокумента, ТекущееЗначение)
	
	Результат = ТекущееЗначение;
	НашлиОбъект = ПолучитьОбъектПоСсылке(ОбъектДокумента, ТекущееЗначение);
	
	Если НашлиОбъект <> Неопределено Тогда
		Результат = ПолучитьЗначениеПоСсылке(ОбъектДокумента, НашлиОбъект.Описание);
	Конецесли;
	
	Возврат Результат;
	
КонецФункции

// По объекту-ссылке получаем сам объект.
//
// Возвращаемое значение:
//  Структура
//
Функция ПолучитьОбъектПоСсылке(ОбъектДокумента, СсылкаОбъекта, ВладелецПоиска = "Объекты")
	
	Результат = Неопределено;
	НашлиОбъект = Неопределено;
	
	Если ПолучитьЗначение(СсылкаОбъекта, "ТипОбъекта") = "Ссылка" Тогда
		НашлиОбъект = ОбъектДокумента[ВладелецПоиска][СсылкаОбъекта.ПолеПоиска];
	ИначеЕсли ТипЗнч(СсылкаОбъекта) = Тип("Массив") И СсылкаОбъекта.Количество() > 0 Тогда
		НашлиОбъект = ПолучитьОбъектПоСсылке(ОбъектДокумента, СсылкаОбъекта[0]);
	КонецЕсли;
	
	Если ПолучитьЗначение(НашлиОбъект, "ТипОбъекта") = "Объект" Тогда
		Результат = НашлиОбъект;
		Если НЕ НашлиОбъект.Инициализирован Тогда
			Если ЗначениеЗаполнено(НашлиОбъект.Позиция) Тогда
				ПерейтиКПозицииДанных(ОбъектДокумента, НашлиОбъект.Позиция);
				ПрочитатьРазделДокумента(ОбъектДокумента);
			ИначеЕсли ЗначениеЗаполнено(НашлиОбъект.Описание) Тогда
				НовыйПарсинг = ОбъектДляПарсинга(ОбъектДокумента, НашлиОбъект.Описание);
				НашлиОбъект.Описание = ПолучитьЗначениеОбъекта(НовыйПарсинг);
				НашлиОбъект.Инициализирован = Истина;
			КонецЕсли;
			ОтразитьСостояниеОперации(ОбъектДокумента, "ЧтениеОбъекта");
		КонецЕсли;

		НашлиОбъект = ПолучитьОбъектПоСсылке(ОбъектДокумента, НашлиОбъект.Описание);
	КонецЕсли;
	
	Если НашлиОбъект <> Неопределено Тогда
		Результат = НашлиОбъект;
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Анализируется описание объекта, и формирует порядок обработки в случае stream.
//
// Возвращаемое значение:
//  Массив
//
Функция ОпределитьТипУпаковкиБлока(ДанныеРаздела)
	
	Результат = Новый Массив;
	ВариантыУпаковки = Новый Соответствие;
	ВариантыУпаковки.Вставить("FlateDecode", "ZIP");
	ВариантыУпаковки.Вставить("ASCII85Decode", "Base85");
	ВариантыУпаковки.Вставить("ASCIIHexDecode", "Hex");
	ВариантыУпаковки.Вставить("Crypt", "Crypt");
	
	ТипУпаковки = ДанныеРаздела["Filter"];
	
	Если НЕ ЗначениеЗаполнено(ТипУпаковки) Тогда
		ТипУпаковки = Новый Массив;
		Результат.Добавить("AsIs");
	ИначеЕсли ТипЗнч(ТипУпаковки) <> Тип("Массив") Тогда
		ТипУпаковки = ОбщегоНазначенияКлиентСервер.ЗначениеВМассиве(ТипУпаковки);
	КонецЕсли;
	
	Для Каждого СтрокаМассива Из ТипУпаковки Цикл
		НашлиЗначение = ВариантыУпаковки[СтрокаМассива];
		Если ЗначениеЗаполнено(НашлиЗначение) Тогда
			Результат.Добавить(НашлиЗначение);
		Иначе
			Результат = Новый Массив;
			Прервать;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

// Разархивирует данные по алгоритму ZIP.
//
// Возвращаемое значение:
//  Строка
//
Функция ПолучитьУпакованныеZIPДанные(ОбъектДокумента, ДанныеРаздела)
	
	Результат = "";
	ОбработкаДанных = ДанныеРаздела;
	Если ТипЗнч(ДанныеРаздела) = Тип("Строка") Тогда
		ОбработкаДанных = ПолучитьБуферДвоичныхДанныхИзСтроки(ДанныеРаздела, ОбъектДокумента.Кодировка);
	Иначе
		ОбработкаДанных = ДанныеРаздела;
	КонецЕсли;
	
	// убрать два первых байта
	ОбщийРазмер = ОбработкаДанных.Размер;
	ВторойБайт = ОбработкаДанных.Получить(1);
	Начало = 2;
	Если ПроверитьБит(ВторойБайт, 5) Тогда
		Начало = Начало + 4;
	КонецЕсли;
	
	ОбработкаДанных = ПолучитьДвоичныеДанныеИзБуфераДвоичныхДанных(ОбработкаДанных.ПолучитьСрез(Начало, ОбщийРазмер - 4 - Начало));
	
	РазмерСжатыхДанных = ОбработкаДанных.Размер();
	
	ИмяСжатогоФайла = "f00000";
	ДанныеРазмерСжатыхДанных = ПеревестиЧислоВДвоичныеДанные(РазмерСжатыхДанных, 4);
	ДанныеИмяСжатогоФайла = ПолучитьДвоичныеДанныеИзСтроки(ИмяСжатогоФайла, ОбъектДокумента.Кодировка);
	ДанныеРазмерCentralDirectory = ПеревестиЧислоВДвоичныеДанные(46 + 6, 4);
	ДанныеСмещениеCentralDirectory = ПеревестиЧислоВДвоичныеДанные(30 + 6 + РазмерСжатыхДанных, 4);
	
	ЧастиZIP = Новый Массив(13);
	ЧастиZIP.Установить(0, Base64Значение("UEsDBBQAAggIAAAAIU4AAAAA"));
	ЧастиZIP.Установить(1, ДанныеРазмерСжатыхДанных);
	ЧастиZIP.Установить(2, Base64Значение("/////wYAAAA="));
	ЧастиZIP.Установить(3, ДанныеИмяСжатогоФайла);
	ЧастиZIP.Установить(4, ОбработкаДанных);
	ЧастиZIP.Установить(5, Base64Значение("UEsBAi4DFAACCAgAAAAhTgAAAAA="));
	ЧастиZIP.Установить(6, ДанныеРазмерСжатыхДанных);
	ЧастиZIP.Установить(7, Base64Значение("/////wYAAAAAAAAAAAAAALSBAAAAAA=="));
	ЧастиZIP.Установить(8, ДанныеИмяСжатогоФайла);
	ЧастиZIP.Установить(9, Base64Значение("UEsFBgAAAAABAAEA"));
	ЧастиZIP.Установить(10, ДанныеРазмерCentralDirectory);
	ЧастиZIP.Установить(11, ДанныеСмещениеCentralDirectory);
	ЧастиZIP.Установить(12, Base64Значение("AAA="));
	
	ОбработкаДанных = СоединитьДвоичныеДанные(ЧастиZIP);
	
	ИмяКаталога = ПолучитьИмяВременногоФайла("zip");
	СоздатьКаталог(ИмяКаталога);
	
	ПотокZIP = Новый ПотокВПамяти(ПолучитьБуферДвоичныхДанныхИзДвоичныхДанных(ОбработкаДанных));
	ИмяФайла = "";
	Попытка
		Файл = Новый ЧтениеZipФайла(ПотокZIP);
		
		Если Файл.Элементы.Количество() > 0 Тогда
			ПервыйЭлемент = Файл.Элементы[0];
			ИмяФайла = ПервыйЭлемент.Имя;
			Файл.Извлечь(ПервыйЭлемент, ИмяКаталога);
		КонецЕсли;
		
	Исключение
		// ВывестиПротокол(ОбъектДокумента, ИнформацияОбОшибке());
		// здесь ничего не предпринимаем, т.к. это ожидаемое поведение
		
	КонецПопытки;
	
	Если ПустаяСтрока(ИмяФайла) Тогда
		Возврат Результат;
	КонецЕсли;
	
	ИмяФайла = ИмяКаталога + ПолучитьРазделительПути() + ИмяФайла;
	ФайлОбработки = Новый Файл(ИмяФайла);
	Если НЕ ФайлОбработки.Существует() Тогда
		Возврат Результат;
	КонецЕсли;
	
	Попытка
		ФайлЧтение  = Новый ЧтениеТекста(ИмяФайла);
		Результат = ФайлЧтение.Прочитать();
		ФайлЧтение.Закрыть();
	Исключение
		ВывестиПротокол(ОбъектДокумента, ИнформацияОбОшибке());
	КонецПопытки;
	
	УдалитьФайлы(ИмяКаталога);
	
	Возврат Результат;
	
КонецФункции

// Строку представленную в формает Base85 преобразует в изначальную строку.
//
// Возвращаемое значение:
//  Строка
//
Функция ПолучитьУпакованныеBase85Данные(ОбъектДокумента, ДанныеРаздела)
	
	Результат = "";
	ОбработкаДанных = ДанныеРаздела;
	ДлинаСтроки = СтрДлина(ОбработкаДанных);
	
	СчетчикПервый = 0;
	СчетчикВторой = 0;
	
	Для Счетчик = 1 По ДлинаСтроки Цикл
		ТекущийСимвол = КодСимвола(ОбработкаДанных, Счетчик);
		
		ОкончаниеЦикла = ТекущийСимвол = 126 ИЛИ Счетчик = ДлинаСтроки; // ~
		Если ОкончаниеЦикла И ТекущийСимвол >= 33 И ТекущийСимвол <= 117 Тогда 
			СчетчикПервый = СчетчикПервый + 1;
			СчетчикВторой = СчетчикВторой * 85 + (ТекущийСимвол - 33);
		КонецЕсли;
			
		Если ОкончаниеЦикла Тогда
			Если СчетчикПервый > 0 Тогда
				Для СчетчикОкончания = 1 По 5 - СчетчикПервый Цикл
					СчетчикВторой = СчетчикВторой * 85 + 84;
				КонецЦикла;
				Результат = Результат + РазложитьЧислоВБайты(СчетчикВторой, СчетчикПервый - 1); 
			КонецЕсли;
			Прервать;
				
		ИначеЕсли ТекущийСимвол >= 33 И ТекущийСимвол <= 117 Тогда // ! - b
			СчетчикПервый = СчетчикПервый + 1;
			СчетчикВторой = СчетчикВторой * 85 + (ТекущийСимвол - 33);
			Если СчетчикПервый = 5 Тогда
				Результат = Результат + РазложитьЧислоВБайты(СчетчикВторой);
				СчетчикПервый = 0;
				СчетчикВторой = 0;
			КонецЕсли;
			
		ИначеЕсли ТекущийСимвол = 122 Тогда // z
			Если СчетчикПервый = 0 Тогда
				ВызватьИсключение "Не корректный формат Base85";
			Иначе
				Результат = Символ(0) + Символ(0) + Символ(0) + Символ(0);
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

// Получает значение потока (stream) для объекта PDF.
//
// Возвращаемое значение:
//  Строка
//
Функция ПолучитьЗначениеРазделаПоток(ОбъектДокумента, ДанныеРаздела)
	
	Результат = "";
	НаборСимволов = ОбъектДокумента.НаборСимволов;
	ДлинаБлока = ПолучитьЗначениеПоСсылке(ОбъектДокумента, ДанныеРаздела["Length"]);
	НачалоБлока = ПолучитьЗначениеПоСсылке(ОбъектДокумента, ДанныеРаздела["Begin"]);
	ТипКодирования = ОпределитьТипУпаковкиБлока(ДанныеРаздела);
	
	Если НЕ ЗначениеЗаполнено(ДлинаБлока) ИЛИ ТипКодирования.Количество() = 0 Тогда
		Возврат Результат;
	КонецЕсли;
	
	ДанныеБлока = ПрочитатьДанныеПотока(ОбъектДокумента, ДлинаБлока, НачалоБлока);
	
	Для Счетчик = 0 По ТипКодирования.Количество() - 1 Цикл
		ТекущийАлгоритм = ТипКодирования[Счетчик];
		
		Если ТекущийАлгоритм = "Crypt" И ДанныеРаздела["DecodeParms"] = Неопределено Тогда
			ТекущийАлгоритм = "AsIs";
		КонецЕсли;
		
		Если ТекущийАлгоритм = "Hex" Тогда
			ДанныеБлока = ПолучитьСтрокуИзHEX(ОбъектДокумента.Кодировка, ДанныеБлока);
		ИначеЕсли ТекущийАлгоритм = "AsIs" Тогда
			Если ТипЗнч(ДанныеБлока) = Тип("БуферДвоичныхДанных") Тогда
				ДанныеБлока = ПолучитьСтрокуИзБуфераДвоичныхДанных(ДанныеБлока, ОбъектДокумента.Кодировка);
			КонецЕсли;
		ИначеЕсли ТекущийАлгоритм = "ZIP" Тогда
			ДанныеБлока = ПолучитьУпакованныеZIPДанные(ОбъектДокумента, ДанныеБлока);
		ИначеЕсли ТекущийАлгоритм = "Base85" Тогда
			ДанныеБлока = ПолучитьУпакованныеBase85Данные(ОбъектДокумента, ДанныеБлока);
		КонецЕсли;
		
	КонецЦикла;
	
	Результат = ДанныеБлока;
	
	Возврат Результат;
	
КонецФункции

// Читает и обрабатывает очередной тег документа.
//
// Возвращаемое значение:
//  Произвольный
//
Функция ПрочитатьРазделДокумента(ОбъектДокумента, ТекущаяСтрока = Неопределено)
	
	Результат = Неопределено;
	НаборСимволов = ОбъектДокумента.НаборСимволов;
	
	Если ТекущаяСтрока = Неопределено Тогда
		ТекущаяСтрока = ПолучитьСледующуюСтроку(ОбъектДокумента);
	КонецЕсли;
	
	Если ТекущаяСтрока = НаборСимволов.НачалоОписания Тогда
		ПолучитьЗначениеРазделаСсылок(ОбъектДокумента);
	ИначеЕсли СтрНайти(ТекущаяСтрока, НаборСимволов.Прицеп) > 0 Тогда
		ПолучитьЗначениеРазделаПрицепа(ОбъектДокумента, ТекущаяСтрока);
	ИначеЕсли Прав(ТекущаяСтрока, 4) = НаборСимволов.Пробел + НаборСимволов.НачалоОбъекта Тогда
		Результат = ПолучитьЗначениеРазделаОбъект(ОбъектДокумента, ТекущаяСтрока);
	ИначеЕсли ТекущаяСтрока = НаборСимволов.ПозицияОписания Тогда
		Результат = ПолучитьЗначениеРазделаСмещение(ОбъектДокумента);
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Извлекает используемую версию PDF в файле.
//
// Возвращаемое значение:
//  Строка
//
Функция ИзвлечьВерсию(ОбъектДокумента)
	
	Результат = "";
	
	ДанныеБлока = ПрочитатьДанныеПотока(ОбъектДокумента, 20, 0, Истина);
	Позиция1 = СтрНайти(ДанныеБлока, "%PDF-");
	Если Позиция1 > 0 Тогда
		Позиция2 = СтрНайти(ДанныеБлока, ОбъектДокумента.НаборСимволов.ВозвратКаретки, , Позиция1);
		Позиция3 = СтрНайти(ДанныеБлока, ОбъектДокумента.НаборСимволов.ПереводСтроки, , Позиция1);
		
		Если Позиция2 > 0 И Позиция3 > 0 Тогда
			Позиция2 = Мин(Позиция2, Позиция3);
		Иначе
			Позиция2 = Макс(Позиция2, Позиция3);
		КонецЕсли;
		
		Если Позиция1 = 1 И Позиция1 < Позиция2 Тогда
			Результат = СокрЛП(Сред(ДанныеБлока, 6, Позиция2 - 6));
		КонецЕсли;
	КонецЕсли;
	
	ОтразитьСостояниеОперации(ОбъектДокумента, "ЧтениеВерсии");
	
	Возврат Результат;
	
КонецФункции

// Извлекает информацию о PDF в файле.
//
// Возвращаемое значение:
//	Структура
//
Функция ИзвлечьИнформациюОДокументе(ОбъектДокумента)
	
	Информация = Неопределено;
	ТочкаНачала = Неопределено;
	МетаИнфо = Неопределено;
	ДействияПользователя = Неопределено;
	
	Если ОбъектДокумента.НачальныйРаздел <> Неопределено Тогда
		ТочкаНачала = ПолучитьЗначениеПоСсылке(ОбъектДокумента, ОбъектДокумента.НачальныйРаздел["Root"]);
		Информация = ПолучитьЗначениеПоСсылке(ОбъектДокумента, ОбъектДокумента.НачальныйРаздел["Info"]);
		МетаИнфо = ПолучитьЗначение(ТочкаНачала, "Metadata");
		ДействияПользователя = ПолучитьЗначение(ТочкаНачала, "AcroForm");
	КонецЕсли;
	
	Если ДействияПользователя <> Неопределено Тогда
		ОбъектДокумента.МетаИнформация.ЕстьПодпись = (ПолучитьЗначение(ДействияПользователя, "SigFlags", 0) % 2) = 1;
	КонецЕсли;
	
	Если МетаИнфо <> Неопределено Тогда
		ИзвлечьМетаданныеДокумента(ОбъектДокумента, МетаИнфо);
	КонецЕсли;
	
	Если Информация <> Неопределено Тогда
		ОбъектДокумента.МетаИнформация.ДатаСоздания = ПолучитьЗначение(Информация, "CreationDate", ОбъектДокумента.МетаИнформация.ДатаСоздания);
		ОбъектДокумента.МетаИнформация.ДатаИзменения = ПолучитьЗначение(Информация, "ModDate", ОбъектДокумента.МетаИнформация.ДатаИзменения);
		ОбъектДокумента.МетаИнформация.Создан = ПроверитьТекстНаСимволы(ПолучитьЗначение(Информация, "Creator", ОбъектДокумента.МетаИнформация.Создан));
		ОбъектДокумента.МетаИнформация.Изменен = ПроверитьТекстНаСимволы(ПолучитьЗначение(Информация, "Producer", ОбъектДокумента.МетаИнформация.Изменен));
		Идентификаторы = ПолучитьЗначение(ОбъектДокумента.НачальныйРаздел, "ID", Новый Массив);
		Для Каждого СтрокаМассива Из Идентификаторы Цикл
			ОбъектДокумента.МетаИнформация.Идентификатор.Добавить(ПроверитьТекстНаСимволы(СтрокаМассива));
		КонецЦикла;
	КонецЕсли;
		
	ОтразитьСостояниеОперации(ОбъектДокумента, "ЧтениеИнформации");

	Возврат ТочкаНачала;
	
КонецФункции

// Извлекает содержимое подписей документа
Процедура ИзвлечьПодписиДокумента(ОбъектДокумента, МассивПолей)
	
	Результат = Новый Массив;
	
	Для Каждого СтрокаМассива Из МассивПолей Цикл
		СсылкаОбъекта = ПолучитьЗначениеПоСсылке(ОбъектДокумента, СтрокаМассива);
		Если ПолучитьЗначение(СсылкаОбъекта, "FT") <> "Sig" Тогда
			Продолжить;
		КонецЕсли;
		ОбъектДокумента.НеобрабатывватьHEXСтроки = Истина;
		ЗаписьСПодписью = ПолучитьОбъектПоСсылке(ОбъектДокумента, СсылкаОбъекта["V"]);
		СодержимоеПодписи = ПолучитьЗначениеПоСсылке(ОбъектДокумента, ЗаписьСПодписью);
		ОбъектДокумента.НеобрабатывватьHEXСтроки = Ложь;
		
		Если ЗаписьСПодписью <> Неопределено Тогда
			НоваяСтрока = ОбъектПодписи();
			НоваяСтрока.УказательДанных = ПолучитьЗначение(ЗаписьСПодписью.Описание, "ByteRange", Новый Массив);
			НоваяСтрока.Подпись = ПолучитьДвоичныеДанныеИзHexСтроки(ПолучитьЗначение(ЗаписьСПодписью.Описание, "Contents", ""));
			НоваяСтрока.Алгоритм = ПолучитьЗначение(ЗаписьСПодписью.Описание, "Filter", "");
			Результат.Добавить(НоваяСтрока);
		КонецЕсли;
		
	КонецЦикла;
	
	ОбъектДокумента.МетаИнформация.Подписи = Результат;
	
КонецПроцедуры

// Извлекает данные о документе из объекта "Metadata"
Процедура ИзвлечьМетаданныеДокумента(ОбъектДокумента, СсылкаМетаданных)
	
	СсылкаОбъекта = ПолучитьЗначениеПоСсылке(ОбъектДокумента, СсылкаМетаданных);
	СодержимоеУзла = ПолучитьСодержимоеУзла(ОбъектДокумента, СсылкаМетаданных);
	
	Если ПолучитьЗначение(СсылкаОбъекта, "Subtype") = "XML" Тогда
		// извлечем данные по формату XMP
		ВсеРеквизиты = ПолучитьЗначенияXML(ОбъектДокумента, СодержимоеУзла);
		ОбъектДокумента.МетаИнформация.Создан = ПолучитьЗначение(ВсеРеквизиты, "CreatorTool", "");
		ОбъектДокумента.МетаИнформация.Изменен = ПолучитьЗначение(ВсеРеквизиты, "Producer", "");
		ОбъектДокумента.МетаИнформация.ДатаСоздания = ПолучитьЗначение(ВсеРеквизиты, "CreateDate");
		ОбъектДокумента.МетаИнформация.ДатаИзменения = ПолучитьЗначение(ВсеРеквизиты, "ModifyDate");
		ОбъектДокумента.МетаИнформация.ФорматАрхива = ПолучитьЗначение(ВсеРеквизиты, "PDFA", "");
	КонецЕсли;
	
КонецПроцедуры

// Получает структуру из xml описания узла
//
// Возвращаемое значение:
//	Соответствие
//
Функция ПолучитьЗначенияXML(ОбъектДокумента, СодержимоеУзла)
	
	Результат = Новый Соответствие;
	НаборСимволов = ОбъектДокумента.НаборСимволов;
	НужноеЗначение = СодержимоеУзла;
	
	Попытка
		//XMP - удаляем служебные вставки для очистки XML
		ПозицияНачало = СтрНайти(НужноеЗначение, НаборСимволов.НачалоВставки);
		ПозицияОкончание = СтрНайти(НужноеЗначение, НаборСимволов.ОкончаниеВставки, , ПозицияНачало + 1);
		Пока ПозицияНачало > 0 И ПозицияОкончание > 0 Цикл
			НужноеЗначение = Сред(НужноеЗначение, 1, ПозицияНачало - 1)
							+ Сред(НужноеЗначение, ПозицияОкончание + СтрДлина(НаборСимволов.ОкончаниеВставки));
			ПозицияНачало = СтрНайти(НужноеЗначение, НаборСимволов.НачалоВставки);
			ПозицияОкончание = СтрНайти(НужноеЗначение, НаборСимволов.ОкончаниеВставки, , ПозицияНачало + 1);
		КонецЦикла;
		
		ЭкранНачало = "&";
		ЭкранОкончание = ";";
		ПозицияНачало = СтрНайти(НужноеЗначение, ЭкранНачало);
		ПозицияОкончание = СтрНайти(НужноеЗначение, ЭкранОкончание, , ПозицияНачало + 1);
		Пока ПозицияНачало > 0 И ПозицияОкончание > 0 Цикл
			НужноеЗначение = Сред(НужноеЗначение, 1, ПозицияНачало - 1)
							+ Сред(НужноеЗначение, ПозицияОкончание + СтрДлина(НаборСимволов.ОкончаниеВставки));
			ПозицияНачало = СтрНайти(НужноеЗначение, ЭкранНачало);
			ПозицияОкончание = СтрНайти(НужноеЗначение, ЭкранОкончание, , ПозицияНачало + 1);
		КонецЦикла;

		ЧтениеСодержимого = Новый ЧтениеXML;
		ЧтениеСодержимого.УстановитьСтроку(ПроверитьТекстНаСимволы(НужноеЗначение));
		
		ЧтениеДокумента = Новый ПостроительDOM;
		НовыйДокумент = ЧтениеДокумента.Прочитать(ЧтениеСодержимого);
		ВсеТеги = ПолучитьВыборкуЭлементовDOM(НовыйДокумент, "rdf:RDF/rdf:Description/*");
		
		ВерсияАрхива = "";
		Для каждого СтрокаМассива Из ВсеТеги Цикл
			Если СтрокаМассива.ИмяУзла = "pdfaid:part" Тогда
				ВерсияАрхива = ВерсияАрхива + "/" + СтрокаМассива.ТекстовоеСодержимое
			ИначеЕсли СтрокаМассива.ИмяУзла = "pdfaid:conformance" Тогда
				ВерсияАрхива = СтрокаМассива.ТекстовоеСодержимое + ВерсияАрхива;
			Иначе
				Результат.Вставить(СтрокаМассива.ЛокальноеИмя, СтрокаМассива.ТекстовоеСодержимое);
			КонецЕсли;
		КонецЦикла;
		
		ВсеТеги = ПолучитьВыборкуЭлементовDOM(НовыйДокумент, "rdf:RDF/rdf:Description/@*");
		
		Для каждого СтрокаМассива Из ВсеТеги Цикл
			Если СтрокаМассива.ИмяУзла = "pdfaid:part" Тогда
				ВерсияАрхива = ВерсияАрхива + "/" + СтрокаМассива.ТекстовоеСодержимое
			ИначеЕсли СтрокаМассива.ИмяУзла = "pdfaid:conformance" Тогда
				ВерсияАрхива = СтрокаМассива.ТекстовоеСодержимое + ВерсияАрхива;
			Иначе
				Результат.Вставить(СтрокаМассива.ЛокальноеИмя, СтрокаМассива.ТекстовоеСодержимое);
			КонецЕсли;
		КонецЦикла;
		
		Если ЗначениеЗаполнено(ВерсияАрхива) Тогда
			Результат.Вставить("PDFA", ВерсияАрхива);
		КонецЕсли;
	Исключение
		ВывестиПротокол(ОбъектДокумента, ИнформацияОбОшибке());
		
	КонецПопытки;
	
	Возврат Результат;
	
КонецФункции

Функция ПолучитьВыборкуЭлементовDOM(УзелВладелец, ТекстПоиска)
	
	Результат = Новый Массив;

	ДокументВладелец = УзелВладелец.ДокументВладелец;
	РазыменовательИмен = Новый РазыменовательПространствИменDOM(ДокументВладелец);
	НашлиЭлементы = ДокументВладелец.ВычислитьВыражениеXPath(ТекстПоиска, УзелВладелец, РазыменовательИмен);
	
	ОчереднойЭлемент = НашлиЭлементы.ПолучитьСледующий();
	Пока ОчереднойЭлемент <> Неопределено Цикл
		Результат.Добавить(ОчереднойЭлемент);
		ОчереднойЭлемент = НашлиЭлементы.ПолучитьСледующий();
	КонецЦикла;	
	
	Возврат Результат;
	
КонецФункции

// Получает содержимое объекта, при необходимости извлекает данные из потока.
//
// Возвращаемое значение:
//  Строка
//
Функция ПолучитьСодержимоеУзла(ОбъектДокумента, ТекущееЗначение)
	
	Результат = "";
	НашлиЗначение = Неопределено;
	
	Если ПолучитьЗначение(ТекущееЗначение, "ТипОбъекта") = "Объект" Тогда
		НашлиЗначение = ТекущееЗначение;
	Иначе
		НашлиЗначение = ПолучитьОбъектПоСсылке(ОбъектДокумента, ТекущееЗначение);
	КонецЕсли;
	
	Если НашлиЗначение = Неопределено Тогда
		Возврат Результат;
	КонецЕсли;
	
	Если НашлиЗначение.Поток Тогда
		НашлиЗначение.Содержимое = ПолучитьЗначениеРазделаПоток(ОбъектДокумента, НашлиЗначение.Описание);
		ПараметрыДекодирования = ПолучитьЗначение(НашлиЗначение.Описание, "DecodeParms");
		АлгоритмСжатия = ПолучитьЗначение(ПараметрыДекодирования, "Predictor", 1);
		Если АлгоритмСжатия >= 10 Тогда
			Цвет = ПолучитьЗначение(ПараметрыДекодирования, "Colors", 1);
			Колонки = ПолучитьЗначение(ПараметрыДекодирования, "Columns", 1);
			БитовыйКомпонент = ПолучитьЗначение(ПараметрыДекодирования, "BitsPerComponent", 8);
			ДанныеСтроки = ПолучитьБуферДвоичныхДанныхИзСтроки(НашлиЗначение.Содержимое, ОбъектДокумента.Кодировка);
			ДанныеСтроки = ПреобразованиеPNG(ОбъектДокумента, АлгоритмСжатия, Цвет, Колонки, БитовыйКомпонент, ДанныеСтроки);
			НашлиЗначение.Содержимое = ПолучитьСтрокуИзБуфераДвоичныхДанных(ДанныеСтроки, ОбъектДокумента.Кодировка);
		КонецЕсли;
		
		НашлиЗначение.Поток = Ложь;
	КонецЕсли;
	
	Результат = НашлиЗначение.Содержимое;
	
	ОтразитьСостояниеОперации(ОбъектДокумента, "ЧтениеПотока");
	
	Возврат Результат;
	
КонецФункции

// Служебная: дополняет соответствие новым значением.
//
// Возвращаемое значение:
//  Соответствие
//
Функция ДобавитьКлюч(ИмяКлюча, ЗначениеКлюча, КоллекцияКлючей = Неопределено)
	
	Если КоллекцияКлючей = Неопределено Тогда
		КоллекцияКлючей = Новый Соответствие;
	Иначе
		Результат = КоллекцияКлючей;
	КонецЕсли;
	
	Результат.Вставить(ИмяКлюча, ЗначениеКлюча);
	
	Возврат Результат;
	
КонецФункции

// Служебная: находит позицию спецсимвола или тега.
//
// Возвращаемое значение:
//  Число
//
Функция ПозицияОператорнойСкобки(ОбъектДокумента, Содержимое, ИмяСкобки, ПозицияНачала, УчестьДлину = 0, Направление = Неопределено)
	
	ТекущееНаправление = НаправлениеПоиска.СНачала;
	Если Направление <> Неопределено Тогда
		ТекущееНаправление = Направление;
	КонецЕсли;
	
	Результат = 0;
	ДлинаСкобки = СтрДлина(ИмяСкобки);
	
	СледующаяПозиция = ПозицияНачала;
	НашлиПозицию = 1;
	Пока НашлиПозицию > 0 Цикл
		НашлиПозицию = СтрНайти(Содержимое, ИмяСкобки, ТекущееНаправление, СледующаяПозиция);
		Если ТекущееНаправление = НаправлениеПоиска.СКонца Тогда
			Если НашлиПозицию > 0 Тогда
				Результат = НашлиПозицию;
				НашлиПозицию = 0;
			КонецЕсли;
		Иначе
			Если НашлиПозицию > 0 И НЕ ЭтоПробельныйСимвол(ОбъектДокумента.НаборСимволов, Сред(Содержимое, НашлиПозицию + СтрДлина(ИмяСкобки), 1)) Тогда
				СледующаяПозиция = НашлиПозицию + ДлинаСкобки;
			ИначеЕсли НашлиПозицию > 0 Тогда
				Результат = НашлиПозицию;
				НашлиПозицию = 0;
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	
	Если Результат <> 0 Тогда
		Результат = Результат + УчестьДлину * ДлинаСкобки;
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Служебная: находит первое из представленного набора спецсимволов или тегов.
//
// Возвращаемое значение:
//  Число
//
Функция НайтиПервоеВхождение(ОбъектДокумента, Содержимое, ВсеРазделы, НачалоПозиции)
	
	Результат = Новый Структура("ИмяРаздела, Позиция", "", 0);
	
	Для Каждого СтрокаКлюча Из ВсеРазделы Цикл
		НашлиПозицию = ПозицияОператорнойСкобки(ОбъектДокумента, Содержимое, СтрокаКлюча.Ключ, НачалоПозиции);
		Если НашлиПозицию > 0 И (НашлиПозицию < Результат.Позиция ИЛИ Результат.Позиция = 0) Тогда
			Результат.ИмяРаздела = СтрокаКлюча.Ключ;
			Результат.Позиция = НашлиПозицию;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

// Находит позицию начала и окончания для операторных скобок с учетом вложенности.
//
// Возвращаемое значение:
//  Структура
//
Функция НайтиОператорныеСкобкиВложенность(ОбъектДокумента, Содержимое, ИмяРаздела, ВсеРазделы, Знач ПозицияНачала)
	
	Результат = Новый Структура("ИмяРаздела, Начало, Окончание", ИмяРаздела, 0, 0);
	НачалоСкобки = ИмяРаздела;
	ОкончаниеСкобки = ВсеРазделы[ИмяРаздела];
	
	Результат.Начало = ПозицияОператорнойСкобки(ОбъектДокумента, Содержимое, НачалоСкобки, ПозицияНачала, 1);
	СледующаяПозиция = Результат.Начало;
	
	Пока СледующаяПозиция > 0 Цикл
		ПозицияОкончания = ПозицияОператорнойСкобки(ОбъектДокумента, Содержимое, ОкончаниеСкобки, СледующаяПозиция);
		ПервыйРаздел = НайтиПервоеВхождение(ОбъектДокумента, Содержимое, ВсеРазделы, СледующаяПозиция);
		Если ПервыйРаздел.Позиция > ПозицияОкончания Тогда
			Прервать;
		КонецЕсли;
		
		СледующаяПозиция = ПервыйРаздел.Позиция;
		
		Если СледующаяПозиция > 0 Тогда
			Описание = НайтиОператорныеСкобкиВложенность(ОбъектДокумента, Содержимое, ПервыйРаздел.ИмяРаздела, ВсеРазделы, СледующаяПозиция);
			СледующаяПозиция = Описание.Окончание;
			ПозицияНачала = СледующаяПозиция;
		КонецЕсли;
			
	КонецЦикла;
	
	Если ПозицияНачала > 0 Тогда
		Результат.Окончание = ПозицияОператорнойСкобки(ОбъектДокумента, Содержимое, ОкончаниеСкобки, ПозицияНачала, 1);
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Извлекает содержимое для операторных скобок с учетом вложенности.
//
// Возвращаемое значение:
//  Строка
//
Функция ПолучитьСодержимоеОператорныхСкобокВложенность(ОбъектДокумента, Содержимое, ИмяРаздела, ВсеРазделы = Неопределено, ПозицияНачала = 1, ПервоеВхождение = Ложь)
	
	Результат = "";
	
	Если ВсеРазделы = Неопределено Тогда
		ВсеРазделы = Новый Соответствие;
		ДобавитьКлюч("beginbfrange", "endbfrange", ВсеРазделы);
		ДобавитьКлюч("begincodespacerange", "endcodespacerange", ВсеРазделы);
		ДобавитьКлюч("begin", "end", ВсеРазделы);
		ДобавитьКлюч("begincmap", "endcmap", ВсеРазделы);
		ДобавитьКлюч("beginbfchar", "endbfchar", ВсеРазделы);
	КонецЕсли;
	
	НачалоСкобки = ИмяРаздела;
	ОкончаниеСкобки = ВсеРазделы[ИмяРаздела];
	
	Если НЕ ЗначениеЗаполнено(ОкончаниеСкобки) Тогда
		ПозицияНачала = 0;
		Возврат Результат;	
	КонецЕсли;
	
	Пока ПозицияНачала > 0 Цикл
		Описание = НайтиОператорныеСкобкиВложенность(ОбъектДокумента, Содержимое, ИмяРаздела, ВсеРазделы, ПозицияНачала);
		ПозицияНачала = Описание.Окончание;
		Если ПозицияНачала > 0 Тогда
			Результат = Результат
						+ СокрЛП(Сред(Содержимое, Описание.Начало, Описание.Окончание - Описание.Начало - СтрДлина(ОкончаниеСкобки)))
						+ ОбъектДокумента.НаборСимволов.ПереводСтроки;
		КонецЕсли;
		Если ПервоеВхождение Тогда
			Прервать;
		КонецЕсли;
	КонецЦикла;
	
	Возврат СокрЛП(Результат);
	
КонецФункции

// Извлекает содержимое для операторных скобок без учета вложенности.
//
// Возвращаемое значение:
//  Строка
//
Функция ПолучитьСодержимоеОператорныхСкобок(ОбъектДокумента, Содержимое, НачалоСкобки, ОкончаниеСкобки, ТекущаяПозиция = 1, Направление = Неопределено, КонтрольноеЗначение = "")
	
	Результат = "";
	
	Если НЕ ЗначениеЗаполнено(ОкончаниеСкобки) Тогда
		ТекущаяПозиция = 0;
		Возврат Результат;	
	КонецЕсли;
	
	ПерваяПозиция = 0;
	ВтораяПозиция = 0;
	КонтрольнаяПозиция = 0;
	
	Если Направление = НаправлениеПоиска.СКонца Тогда
		ВтораяПозиция = СтрНайти(Содержимое, ОкончаниеСкобки, Направление, ТекущаяПозиция);
		Если ЗначениеЗаполнено(КонтрольноеЗначение) И ВтораяПозиция > 0 Тогда
			КонтрольнаяПозиция = СтрНайти(Содержимое, КонтрольноеЗначение, Направление, ТекущаяПозиция);
			КонтрольнаяПозиция = ?(КонтрольнаяПозиция > 0 И КонтрольнаяПозиция < ВтораяПозиция И КонтрольнаяПозиция < ТекущаяПозиция , 0, КонтрольнаяПозиция);
		КонецЕсли;
		Если ВтораяПозиция > 0 Тогда
			ПерваяПозиция = СтрНайти(Содержимое, НачалоСкобки, Направление, ВтораяПозиция);
			ТекущаяПозиция = ПерваяПозиция;
		КонецЕсли;
	Иначе
		ПерваяПозиция = СтрНайти(Содержимое, НачалоСкобки, , ТекущаяПозиция);
		Если ЗначениеЗаполнено(КонтрольноеЗначение) И ПерваяПозиция > 0 Тогда
			КонтрольнаяПозиция = СтрНайти(Содержимое, КонтрольноеЗначение, , ТекущаяПозиция);
			КонтрольнаяПозиция = ?(КонтрольнаяПозиция > 0 И КонтрольнаяПозиция > ПерваяПозиция, 0, КонтрольнаяПозиция);
		КонецЕсли;
		Если ПерваяПозиция > 0 Тогда
			ВтораяПозиция = СтрНайти(Содержимое, ОкончаниеСкобки, , ПерваяПозиция);
			ТекущаяПозиция = ВтораяПозиция + СтрДлина(ОкончаниеСкобки);
		КонецЕсли;
	КонецЕсли;
	
	Если ПерваяПозиция > 0 И ВтораяПозиция > 0 И КонтрольнаяПозиция = 0 Тогда
		Результат = Сред(Содержимое, ПерваяПозиция, ВтораяПозиция - ПерваяПозиция);
	Иначе
		ТекущаяПозиция = 0;
	КонецЕсли;
	
	Возврат СокрЛП(Результат);
	
КонецФункции

// Формирует информацию объекта-штрифта.
// Учитывается вложенность шрифтов, таблицы кодировок, способы кодировок
//
// Возвращаемое значение:
//	Структура
//
Функция ПодготовитьШрифтДокумента(ОбъектДокумента, СсылкаОбъекта, ТаблицаСимволов = Неопределено, ТипКодировки = Неопределено)
	
	Результат = ОбъектШрифта();
	
	ДанныеУзла = ПолучитьОбъектПоСсылке(ОбъектДокумента, СсылкаОбъекта);
	Если ДанныеУзла = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	ТипОбъекта = ПолучитьЗначение(ДанныеУзла.Описание, "Type");
	Если ТипОбъекта <> "Font" Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Результат.ТипШрифта = ПолучитьЗначение(ДанныеУзла.Описание, "Subtype");
	// Варианты:
	// 	CIDFontType
	//	CIDFontType2
	//	DescendantFonts
	//	TrueType
	//	Type0
	//	Type1
	//	Type3
	//	MMType1
	
	Если ТаблицаСимволов = Неопределено Тогда
		ТаблицаСимволов = ПолучитьЗначение(ДанныеУзла.Описание, "ToUnicode");
	КонецЕсли;
	
	Если ТипКодировки = Неопределено Тогда
		ТипКодировки = ПолучитьЗначение(ДанныеУзла.Описание, "Encoding");
	КонецЕсли;
	
	Если ТипКодировки <> Неопределено Тогда
		Результат.ТипКодировки = ТипКодировки;
	КонецЕсли;
	
	Если Результат.ТипШрифта = "Type0" Тогда
		ВложенныеШрифты = ПолучитьЗначение(ДанныеУзла.Описание, "DescendantFonts");
		Если ЗначениеЗаполнено(ВложенныеШрифты) И ТипЗнч(ВложенныеШрифты) <> Тип("Массив") Тогда
			ВложенныеШрифты = ОбщегоНазначенияКлиентСервер.ЗначениеВМассиве(ВложенныеШрифты);
		КонецЕсли;
		
		Если ВложенныеШрифты.Количество() > 0 Тогда 
			Возврат ПодготовитьШрифтДокумента(ОбъектДокумента, ВложенныеШрифты[0], ТаблицаСимволов, ТипКодировки);
		КонецЕсли;
		
	ИначеЕсли СтрНайти("CIDFontType, CIDFontType2", Результат.ТипШрифта) > 0 Тогда
		Результат.Байтов = 2;
		
	КонецЕсли;
	
	ПеречислениеДиапазонов = "";
	ПеречислениеСимволов = "";
	Если ТаблицаСимволов <> Неопределено Тогда
		Содержимое = ПолучитьСодержимоеУзла(ОбъектДокумента, ТаблицаСимволов);
		ПеречислениеДиапазонов = ПолучитьСодержимоеОператорныхСкобокВложенность(ОбъектДокумента, Содержимое, "beginbfrange");
		ПеречислениеСимволов = ПолучитьСодержимоеОператорныхСкобокВложенность(ОбъектДокумента, Содержимое, "beginbfchar");
	КонецЕсли;
	
	Если ЗначениеЗаполнено(ПеречислениеДиапазонов) Тогда
		ДанныеРаздела = Новый Массив;
		ПеречислениеДиапазонов = СтрЗаменить(ПеречислениеДиапазонов, ОбъектДокумента.НаборСимволов.ПереводСтроки, " ");
		ПеречислениеДиапазонов = СтрЗаменить(ПеречислениеДиапазонов, "><", "> <");
		ПеречислениеДиапазонов = СтрЗаменить(ПеречислениеДиапазонов, ОбъектДокумента.НаборСимволов.НачалоHEXСтроки, "(");
		ПеречислениеДиапазонов = СтрЗаменить(ПеречислениеДиапазонов, ОбъектДокумента.НаборСимволов.ОкончаниеHEXСтроки, ")");
		НовыйПарсинг = ОбъектДляПарсинга(ОбъектДокумента, "[" + ПеречислениеДиапазонов + "]");
		ДанныеРаздела = ПолучитьЗначениеОбъекта(НовыйПарсинг);
		
		Всего = ДанныеРаздела.Количество() / 3;
		Для Счетчик = 0 По Всего - 1 Цикл
			
			ПервыйЭлемент = Счетчик * 3;
			Начало = ПолучитьЧислоИзHEX(ДанныеРаздела[ПервыйЭлемент]);
			Окончание = ПолучитьЧислоИзHEX(ДанныеРаздела[ПервыйЭлемент + 1]);
			ТочкаОтсчета = ДанныеРаздела[ПервыйЭлемент + 2];
			ЭтоМассив = ТипЗнч(ТочкаОтсчета) = Тип("Массив");
			Если НЕ ЭтоМассив Тогда
				ТочкаОтсчета = ПолучитьЧислоИзHEX(ТочкаОтсчета);
			КонецЕсли;
			
			Индекс = 0;
			Для СчетчикСимволов = Начало По Окончание Цикл
				Если ЭтоМассив Тогда
					Результат.ТаблицаСоответствия.Вставить(СчетчикСимволов, Символ(ПолучитьЧислоИзHEX(ТочкаОтсчета[Индекс])));
				Иначе
					Результат.ТаблицаСоответствия.Вставить(СчетчикСимволов, Символ(ТочкаОтсчета + Индекс));
				КонецЕсли;
				Индекс = Индекс + 1;
			КонецЦикла;
			
		КонецЦикла;
		
	КонецЕсли;
	
	Если ЗначениеЗаполнено(ПеречислениеСимволов) Тогда
		ДанныеРаздела = Новый Массив;
		ПеречислениеСимволов = СтрЗаменить(ПеречислениеСимволов, ОбъектДокумента.НаборСимволов.ПереводСтроки, " ");
		ПеречислениеСимволов = СтрЗаменить(ПеречислениеСимволов, "><", "> <");
		ПеречислениеСимволов = СтрЗаменить(ПеречислениеСимволов, ОбъектДокумента.НаборСимволов.НачалоHEXСтроки, "(");
		ПеречислениеСимволов = СтрЗаменить(ПеречислениеСимволов, ОбъектДокумента.НаборСимволов.ОкончаниеHEXСтроки, ")");
		НовыйПарсинг = ОбъектДляПарсинга(ОбъектДокумента, "[" + ПеречислениеСимволов + "]");
		ДанныеРаздела = ПолучитьЗначениеОбъекта(НовыйПарсинг);
		
		Всего = ДанныеРаздела.Количество() / 2;
		Для Счетчик = 0 По Всего - 1 Цикл
			ПервыйЭлемент = Счетчик * 2;
			КодСоответствия1 = ПолучитьЧислоИзHEX(ДанныеРаздела[ПервыйЭлемент]);
			КодСоответствия2 = ПолучитьЧислоИзHEX(ДанныеРаздела[ПервыйЭлемент + 1]);
			Результат.ТаблицаСоответствия.Вставить(КодСоответствия1, Символ(КодСоответствия2));
		КонецЦикла;
		
	КонецЕсли;
	
	ОбъектДокумента.Шрифты.Вставить(СсылкаОбъекта.ПолеПоиска, Результат);
	
	ОтразитьСостояниеОперации(ОбъектДокумента, "ЧтениеИнформацииОШрифте");
	
	Возврат Результат;
	
КонецФункции

// Готовит реестр страниц, обнаруженных в документе, анализируется поле "Root" в прицепе.
//
Процедура ВыборкаДереваСтраниц(ОбъектДокумента, ТочкаНачала)
	
	ТекущийУзел = ПолучитьОбъектПоСсылке(ОбъектДокумента, ТочкаНачала); 
	ТипУзла = ПолучитьЗначение(ТекущийУзел.Описание, "Type", "");
	
	Если ТипУзла = "Pages" Тогда
		ТекущиеСтраницы = ПолучитьЗначение(ТекущийУзел.Описание, "Kids", Новый Массив);
		Для Каждого СтрокаМассива Из ТекущиеСтраницы Цикл
			Если ОбъектДокумента.УскоритьПолучениеСтраниц Тогда
				ОбъектДокумента.Страницы.Добавить(СтрокаМассива);
			Иначе
				ВыборкаДереваСтраниц(ОбъектДокумента, СтрокаМассива);
			КонецЕсли;
		КонецЦикла;
	ИначеЕсли ТипУзла = "Page" Тогда
		ОбъектДокумента.Страницы.Добавить(ТочкаНачала);
	КонецЕсли;
	
	ОтразитьСостояниеОперации(ОбъектДокумента, "ЧтениеДереваСтраниц");

КонецПроцедуры

// Для каждой страницы формируется свой реестр шрифтов.
// Где ключ - специфическое имя для данной страницы, ключ объект-ссылка.
//
// Возвращаемое значение:
//	Структура
//
Функция ПодготовитьШрифтыСтраницы(ОбъектДокумента, РесурсУзла, НаборШтрифтов = Неопределено)
	
	Если НаборШтрифтов = Неопределено Тогда
		НаборШтрифтов = Новый Соответствие;
	КонецЕсли;
	
	Если РесурсУзла = Неопределено Тогда
		Возврат НаборШтрифтов;
	КонецЕсли;
	
	Если ТипЗнч(РесурсУзла) = Тип("Структура") Тогда // Ссылка
		ТекущийУзел = ПолучитьОбъектПоСсылке(ОбъектДокумента, РесурсУзла); 
		ПодготовитьШрифтыСтраницы(ОбъектДокумента, ТекущийУзел.Описание, НаборШтрифтов);
		
	ИначеЕсли ТипЗнч(РесурсУзла) = Тип("Соответствие") Тогда // Словарь
		ЗначениеШрифта = ПолучитьЗначение(РесурсУзла, "Font");
		
		Если ЗначениеШрифта <> Неопределено Тогда
			ПодготовитьШрифтыСтраницы(ОбъектДокумента, ЗначениеШрифта, НаборШтрифтов);
			
		Иначе
			Для каждого СтрокаМассива Из РесурсУзла Цикл
				ИмяШрифта = СтрокаМассива.Ключ;
				НашлиШрифт = ПолучитьОбъектПоСсылке(ОбъектДокумента, СтрокаМассива.Значение, "Шрифты");
				Если НашлиШрифт = Неопределено Тогда
					НашлиШрифт = ПодготовитьШрифтДокумента(ОбъектДокумента, СтрокаМассива.Значение);
				КонецЕсли;
				
				Если НашлиШрифт <> Неопределено Тогда
					НаборШтрифтов.Вставить(ИмяШрифта, НашлиШрифт);
				КонецЕсли;
				
			КонецЦикла;
			
		КонецЕсли;
		
	КонецЕсли;
	
	Возврат НаборШтрифтов;
	
КонецФункции

// Базовая функция для извлечения текста страницы.
//
// Общая схема:
//	- первичное чтение файла: общая информация, список ссылок документа и точка входа
//	- составление реестра страниц
//	- обход каждой страницы:
//		- подготовка реестра шрифтов
//		- извлечение текста из потока
//		- выделение блоков с текстом
//		- конвертирование номеров глифов в коды символов
//
// Возвращаемое значение:
//	Строка
//
Функция РазобратьТекстУзла(ОбъектДокумента, ТекстУзла, ШрифтыСтраницы)
	
	Результат = "";

	НаборСимволов = ОбъектДокумента.НаборСимволов;
	НачалоТекста = НаборСимволов.НачалоТекста;
	ОкончаниеТекста = НаборСимволов.ОкончаниеТекста;
	МаркерОдинарнаяКавычка = НаборСимволов.МаркерОдинарнаяКавычка;
	МаркерДвойнаяКавычка = НаборСимволов.МаркерДвойнаяКавычка;
	МаркерОтобразить = НаборСимволов.МаркерОтобразить;
	МаркерСПозицией = НаборСимволов.МаркерСПозицией;
	МаркерШрифта = НаборСимволов.МаркерШрифта;
	МаркерПереноса = НаборСимволов.МаркерПереноса;
	МаркерПереносаНаПозицию = НаборСимволов.МаркерПереносаНаПозицию;
	МаркерПереносаНаПозицию1 = НаборСимволов.МаркерПереносаНаПозицию1;
	
	НаборСтрок = Новый Массив;
	ВсеСтроки = Новый Массив;
	
	// Формируем информацию о каждой строке
	СписокМаркеров = Новый Соответствие;
	СписокМаркеров.Вставить(") " + МаркерОдинарнаяКавычка, "");
	СписокМаркеров.Вставить(") " + МаркерДвойнаяКавычка, "");
	СписокМаркеров.Вставить(" " + МаркерОтобразить, "");
	СписокМаркеров.Вставить(" " + МаркерСПозицией, "");
	СписокМаркеров.Вставить(" " + МаркерШрифта, "");
	СписокМаркеров.Вставить(" " + МаркерПереноса, "");
	СписокМаркеров.Вставить(" " + МаркерПереносаНаПозицию, "");
	СписокМаркеров.Вставить(" " + МаркерПереносаНаПозицию1, "");
	
	// ради разделения строк
	СписокМаркеров.Вставить(" Td", "");
	СписокМаркеров.Вставить(" Tc", "");
	СписокМаркеров.Вставить(" Tw", "");
	СписокМаркеров.Вставить("BT ", "");
	
	// реальные теги
	СписокМаркеров.Вставить(МаркерОдинарнаяКавычка, МаркерОдинарнаяКавычка);
	СписокМаркеров.Вставить(МаркерДвойнаяКавычка, МаркерДвойнаяКавычка);
	СписокМаркеров.Вставить(МаркерОтобразить, МаркерОтобразить);
	СписокМаркеров.Вставить(МаркерСПозицией, МаркерСПозицией);
	СписокМаркеров.Вставить(МаркерШрифта, МаркерШрифта);
	СписокМаркеров.Вставить(МаркерПереноса, МаркерПереноса);
	СписокМаркеров.Вставить(МаркерПереносаНаПозицию, МаркерПереносаНаПозицию);
	СписокМаркеров.Вставить(МаркерПереносаНаПозицию1, МаркерПереносаНаПозицию1);
	
	СодержимоеСтраницы = ТекстУзла;
	Для Каждого СтрокаКлюча Из СписокМаркеров Цикл
		Если ПустаяСтрока(СтрокаКлюча.Значение) Тогда 
			СодержимоеСтраницы = СтрЗаменить(СодержимоеСтраницы, СтрокаКлюча.Ключ, СтрокаКлюча.Ключ + НаборСимволов.ПереводСтроки);
		КонецЕсли;
	КонецЦикла;
		
	ПозицияТекста = 1;
	ПозицияШрифта = 1;
	Пока ПозицияТекста > 0 Цикл
		ОписаниеТекста = ПолучитьСодержимоеОператорныхСкобок(ОбъектДокумента, СодержимоеСтраницы, НачалоТекста, ОкончаниеТекста, ПозицияТекста);
		
		Если ПустаяСтрока(ОписаниеТекста) Тогда
			Продолжить;
		КонецЕсли;
		
		ОписаниеШрифта = "";
		
		НачалоБлокаТекста = ПозицияТекста - СтрДлина(ОписаниеТекста);
		
		ПозицияШрифта = НачалоБлокаТекста;
		ОписаниеШрифта = ПолучитьСодержимоеОператорныхСкобок(ОбъектДокумента, СодержимоеСтраницы, "/", МаркерШрифта, ПозицияШрифта, НаправлениеПоиска.СКонца, ОкончаниеТекста);
		
		Если НЕ ПустаяСтрока(ОписаниеШрифта) Тогда
			НовыйПарсинг = ОбъектДляПарсинга(ОбъектДокумента, ОписаниеШрифта);
			ОписаниеШрифта = ПолучитьЗначениеТипаИмя(НовыйПарсинг);
		КонецЕсли;
		
		ЭтоПеренос = Ложь;
		ПозицияСтроки = СтрНайти(СодержимоеСтраницы, НачалоТекста, НаправлениеПоиска.СКонца, НачалоБлокаТекста);
		Если ПозицияСтроки > 0 Тогда
			ПозицияСтроки = СтрНайти(СодержимоеСтраницы, НаборСимволов.ПереводСтроки, НаправлениеПоиска.СКонца, ПозицияСтроки);
		КонецЕсли;
		Если ПозицияСтроки > 0 Тогда
			ЭтоПеренос = СтрНайти(Сред(СодержимоеСтраницы, ПозицияСтроки, ПозицияТекста - ПозицияСтроки), "/P") <> 0;
		КонецЕсли;
		
		НоваяСтрока = Новый Структура("Текст, ЭтоПеренос, ИмяШрифта", ОписаниеТекста, ЭтоПеренос, ОписаниеШрифта);
		НаборСтрок.Добавить(НоваяСтрока);
	КонецЦикла;
	
	ИмяШрифта = "";
	
	// новый вариант
	Для Каждого СтрокаМассива Из НаборСтрок Цикл
		
		ЭтоПеренос = СтрокаМассива.ЭтоПеренос;
		КоличествоСтрок = СтрЧислоСтрок(СтрокаМассива.Текст);
		Для Счетчик = 1 По КоличествоСтрок Цикл
			ТекущаяСтрока = СокрЛП(СтрПолучитьСтроку(СтрокаМассива.Текст, Счетчик));
			
			Если ПустаяСтрока(ТекущаяСтрока) Тогда
				Продолжить;
			КонецЕсли;
			
			ДлинаСтроки = СтрДлина(ТекущаяСтрока);
			
			ДваСимвола = Прав(ТекущаяСтрока, 2);
			ИмяРаздела = Неопределено;
			Если СписокМаркеров[ДваСимвола] <> Неопределено Тогда
				ИмяРаздела = СписокМаркеров[ДваСимвола];
			КонецЕсли;
			
			ДобавитьСтроку = Ложь;
			
			Если ИмяРаздела = Неопределено Тогда
				Продолжить;
			КонецЕсли;
			
			СодержимоеМаркера = Лев(ТекущаяСтрока, ДлинаСтроки - СтрДлина(ИмяРаздела));
			
			Если ИмяРаздела = МаркерОдинарнаяКавычка
				ИЛИ ИмяРаздела = МаркерДвойнаяКавычка Тогда
				ДобавитьСтроку = Истина;
				
			ИначеЕсли ИмяРаздела = МаркерОтобразить
				ИЛИ ИмяРаздела = МаркерСПозицией Тогда
				ДобавитьСтроку = Истина;
				
			ИначеЕсли ИмяРаздела = МаркерПереноса 
				ИЛИ ИмяРаздела = МаркерПереносаНаПозицию1 Тогда
				ЭтоПеренос = Истина;
				
			ИначеЕсли ИмяРаздела = МаркерШрифта Тогда
				НовыйПарсинг = ОбъектДляПарсинга(ОбъектДокумента, СодержимоеМаркера);
				ИмяШрифта = ПолучитьЗначениеТипаИмя(НовыйПарсинг);
				
			ИначеЕсли ИмяРаздела = МаркерПереносаНаПозицию Тогда
				Подстроки = СтрРазделить(СодержимоеМаркера, НаборСимволов.Пробел, " ");
				ЭтоПеренос = Подстроки[Подстроки.Количество() - 1] <> "0";
				
			КонецЕсли;
				
			Если ДобавитьСтроку Тогда
				СодержимоеСтроки = ОптимальныйРазборБлокаТекста(ОбъектДокумента, СодержимоеМаркера, ИмяРаздела);
				
				НоваяСтрока = ОбъектКодированнойСтроки();
				НоваяСтрока.Маркер = ИмяРаздела;
				НоваяСтрока.Содержание = СодержимоеСтроки;
				Если ЗначениеЗаполнено(ИмяШрифта) Тогда
					НоваяСтрока.Шрифт = ИмяШрифта;
				Иначе
					НоваяСтрока.Шрифт = СтрокаМассива.ИмяШрифта;
				КонецЕсли;
				НоваяСтрока.ЭтоПеренос = ЭтоПеренос;
				НоваяСтрока.Содержание = ПреобразоватьСтрокуОбъекта(ОбъектДокумента, НоваяСтрока, ШрифтыСтраницы);
				ВсеСтроки.Добавить(НоваяСтрока);
				
				ЭтоПеренос = Ложь;
				
			КонецЕсли;
				
		КонецЦикла;
		
	КонецЦикла;
	
	// пытаемся раскодировать строки
	Для Каждого СтрокаМассива Из ВсеСтроки Цикл
		Результат = Результат + СтрокаМассива.Содержание;
		Если СтрокаМассива.ЭтоПеренос Тогда
			Результат = Результат + НаборСимволов.ПереводСтроки;
		ИначеЕсли СтрокаМассива.Маркер = МаркерОтобразить Тогда
//			Результат = Результат + НаборСимволов.Пробел;
		КонецЕсли;
	КонецЦикла;
	
	ОтразитьСостояниеОперации(ОбъектДокумента, "ЧтениеТекстовогоБлока");
	
	Возврат Результат;
	
КонецФункции

// Оптимизация разбора текста для ожидаемых конструкций [<(
//
// Возвращаемое значение:
//	Строка
//
Функция ОптимальныйРазборБлокаТекста(ОбъектДокумента, СодержимоеМаркера, ИмяРаздела, Оптимизировать = Истина)
	
	Результат = "";
	
	Если Оптимизировать Тогда
		НаборСимволов = ОбъектДокумента.НаборСимволов;
		ДлинаСтроки = СтрДлина(СодержимоеМаркера) + 1;
		
		Попытка
			ТекущаяПозиция = 1;
			Пока ТекущаяПозиция > 0 Цикл
				
				Позиция2 = СтрНайти(СодержимоеМаркера, НаборСимволов.НачалоСтроки, , ТекущаяПозиция);
				Если Позиция2 > 0 И Сред(СодержимоеМаркера, Позиция2 - 1, 1) = НаборСимволов.Экран Тогда
					Позиция2 = 0;
				КонецЕсли;
				Позиция3 = СтрНайти(СодержимоеМаркера, НаборСимволов.НачалоHEXСтроки, , ТекущаяПозиция);
				
				Если Позиция2 > 0 И (Позиция3 = 0 ИЛИ Позиция3 > Позиция2) Тогда
					ТекущаяПозиция = СтрНайти(СодержимоеМаркера, НаборСимволов.ОкончаниеСтроки, , Позиция2);
					ТекущаяПозиция = ?(ТекущаяПозиция > 0 И Сред(СодержимоеМаркера, ТекущаяПозиция - 1, 1) = НаборСимволов.Экран, 0, ТекущаяПозиция);
					Если ТекущаяПозиция > 0 Тогда
						НовыйПарсинг = ОбъектДляПарсинга(ОбъектДокумента, Сред(СодержимоеМаркера, Позиция2, ТекущаяПозиция - Позиция2));
						Результат = Результат + ПолучитьЗначениеТипаСтрока(НовыйПарсинг, Истина);
					КонецЕсли;
				ИначеЕсли Позиция3 > 0 Тогда
					ТекущаяПозиция = СтрНайти(СодержимоеМаркера, НаборСимволов.ОкончаниеHEXСтроки, , Позиция3);
					Если ТекущаяПозиция > 0 Тогда
						Результат = Результат + ПолучитьСтрокуИзHEX(ОбъектДокумента.Кодировка, Сред(СодержимоеМаркера, Позиция3 + 1, ТекущаяПозиция - Позиция3 - 1));
					КонецЕсли;
				Иначе
					ТекущаяПозиция = 0;
				КонецЕсли;
				
			КонецЦикла;
		Исключение
			Результат = "";
		КонецПопытки;
		
	КонецЕсли;
	
	Если СтрДлина(Результат) = 0 Тогда
		НовыйПарсинг = ОбъектДляПарсинга(ОбъектДокумента, СодержимоеМаркера);
		ЗакодированнаяСтрока = ПолучитьЗначениеОбъекта(НовыйПарсинг);
		
		Если ТипЗнч(ЗакодированнаяСтрока) = Тип("Массив") Тогда
			СодержимоеСтроки = "";
			Для СчетчикСтроки = 0 По ЗакодированнаяСтрока.Количество() - 1 Цикл
				ЗначениеМассива = ЗакодированнаяСтрока[СчетчикСтроки];
				Если ТипЗнч(ЗначениеМассива) = Тип("Строка") Тогда
					Результат = Результат + ЗначениеМассива;
				КонецЕсли;
			КонецЦикла;
		Иначе
			Результат = ЗакодированнаяСтрока;
		КонецЕсли;
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Производится конвертация из номеров глифов в коды символов.
//
// Возвращаемое значение:
//	Число
//
Функция ПреобразоватьСтрокуОбъекта(ОбъектДокумента, ОбъектСтроки, ШрифтыСтраницы)
	
	ТекущийШрифт = ШрифтыСтраницы[ОбъектСтроки.Шрифт];
	Содержание = ОбъектСтроки.Содержание;
	Результат = "";
	
	Если ТекущийШрифт = Неопределено Тогда
		Возврат Содержание;
	КонецЕсли;
		
	ДлинаСтроки = СтрДлина(Содержание);
	
	Если ТекущийШрифт.ТипКодировки = "WinAnsiEncoding" Тогда
		Результат = Содержание;
	Иначе
		ТаблицаСоответствия = ТекущийШрифт.ТаблицаСоответствия;
		
		Если ДлинаСтроки % 2 = 1 И ТекущийШрифт.Байтов = 2 Тогда
			Содержание = Содержание + Символ(0);
		КонецЕсли;
		
		МассивБайтов = ПолучитьБуферДвоичныхДанныхИзСтроки(Содержание, ОбъектДокумента.Кодировка);
		ДлинаСтроки = МассивБайтов.Размер;
		
		Если ТекущийШрифт.Байтов = 1 Тогда
			Для Счетчик = 0 По ДлинаСтроки - 1 Цикл
				Результат = Результат + ПолучитьСимволСоответствия(ТаблицаСоответствия, МассивБайтов.Получить(Счетчик));
			КонецЦикла;
			
		Иначе
			Счетчик = 0;
			Пока Счетчик < ДлинаСтроки Цикл
				Результат = Результат + ПолучитьСимволСоответствия(ТаблицаСоответствия, МассивБайтов.ПрочитатьЦелое16(Счетчик, ПорядокБайтов.BigEndian));
				Счетчик = Счетчик + 2;
			КонецЦикла;
			
		КонецЕсли;
	КонецЕсли;
	
	Возврат ПроверитьТекстНаСимволы(Результат);
	
КонецФункции

// Поиск номер глифа в таблице соответствий.
//
// Возвращаемое значение:
//	Строка
//
Функция ПолучитьСимволСоответствия(ТаблицаСоответствия, ТекущийКод)
	
	Если ТаблицаСоответствия.Количество() = 0 Тогда
		Результат = Символ(ТекущийКод);
	Иначе	
		Результат = ТаблицаСоответствия[ТекущийКод];
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Анализ ссылок на странице для извлечения текста.
//
// Возвращаемое значение:
//	Строка
//
Функция ПодготовитьТекстСтраницы(ОбъектДокумента, СодержимоеУзла)
	
	Результат = "";
	
	Если СодержимоеУзла = Неопределено Тогда
		Возврат Результат;
	КонецЕсли;
	
	Если ТипЗнч(СодержимоеУзла) = Тип("Структура") Тогда // Ссылка
		Результат = ПолучитьСодержимоеУзла(ОбъектДокумента, СодержимоеУзла);
		
	ИначеЕсли ТипЗнч(СодержимоеУзла) = Тип("Массив") Тогда // Массив ссылок
		Для Каждого СтрокаМассива Из СодержимоеУзла Цикл
			Результат = Результат + ?(ПустаяСтрока(Результат), "", ОбъектДокумента.НаборСимволов.ПереводСтроки)
						+ ПодготовитьТекстСтраницы(ОбъектДокумента, СтрокаМассива);
		КонецЦикла;
		
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Подготовка страниц для извлечения текста.
//
// Возвращаемое значение:
//	Строка
//
Процедура ИзвлечьСтраницы(ОбъектДокумента)
	
	ВесьТекст = "";
	
	Для Каждого СтрокаМассива Из ОбъектДокумента.Страницы Цикл
		ТекущийУзел = ПолучитьОбъектПоСсылке(ОбъектДокумента, СтрокаМассива); 
		Ресурсы = ПолучитьЗначение(ТекущийУзел.Описание, "Resources");
		Содержимое = ПолучитьЗначение(ТекущийУзел.Описание, "Contents");
		
		Если Ресурсы = Неопределено Тогда
			Продолжить;
		КонецЕсли;
		
		ШрифтыСтраницы = ПодготовитьШрифтыСтраницы(ОбъектДокумента, Ресурсы);
		Если ШрифтыСтраницы.Количество() > 0 И Содержимое <> Неопределено Тогда
			СводноеСодержимое = ПодготовитьТекстСтраницы(ОбъектДокумента, Содержимое);
			ВесьТекст = ВесьТекст + РазобратьТекстУзла(ОбъектДокумента, СводноеСодержимое, ШрифтыСтраницы) + ОбъектДокумента.НаборСимволов.ПереводСтроки;
		КонецЕсли;
		
	КонецЦикла;
	
	ОбъектДокумента.ТекстДокумента = ВесьТекст;
	
КонецПроцедуры

Процедура ОтразитьСостояниеОперации(ОбъектДокумента, ВидОперации)
	
	Если ОбъектДокумента.ДетальныйАнализПроизводительности Тогда
		
		НашлиСчетчик = ОбъектДокумента.СписокОпераций[ВидОперации];
		Если НашлиСчетчик = Неопределено Тогда
			НашлиСчетчик = Новый Структура("Всего, Время", 0, 0);
			ОбъектДокумента.СписокОпераций.Вставить(ВидОперации, НашлиСчетчик);
		КонецЕсли;
		
		НовыйЗамер = ТекущаяУниверсальнаяДатаВМиллисекундах();
		НашлиСчетчик.Всего = НашлиСчетчик.Всего + 1;
		НашлиСчетчик.Время = НашлиСчетчик.Время + НовыйЗамер - ОбъектДокумента.Замер;
		ОбъектДокумента.Замер = НовыйЗамер;
		
	КонецЕсли;
	
КонецПроцедуры

Процедура ОтразитьСостояниеЗамера(ОбъектДокумента, ВидОперации, ТекущийЗамер)
	
	Если ОбъектДокумента.ДетальныйАнализПроизводительности Тогда
		
		НовыйЗамер = ТекущаяУниверсальнаяДатаВМиллисекундах();
		Сообщить(ВидОперации + ": " + СокрЛП(НовыйЗамер - ТекущийЗамер));
		ТекущийЗамер = НовыйЗамер;
		
	КонецЕсли;
	
КонецПроцедуры

Функция ЕстьРежим(ОбъектДокумента, ТекущийРежим)
	
	МассивДействий = СтрРазделить(ОбъектДокумента.РежимПарсинга, ",");
	Результат = МассивДействий.Найти(ТекущийРежим) <> Неопределено;
	
	Возврат Результат;
	
КонецФункции

Процедура РежимПарсингаТекст(ОбъектДокумента, ТекущийОтсчет)
	
	Если ЕстьРежим(ОбъектДокумента, "Текст") Тогда
		ИзвлечьСтраницы(ОбъектДокумента);
		ОтразитьСостояниеЗамера(ОбъектДокумента, "Извлечение текста общее", ТекущийОтсчет);
	КонецЕсли;
	
КонецПроцедуры

Процедура РежимПарсингаПодписи(ОбъектДокумента, ТочкаНачала, ТекущийОтсчет)
	
	Если ЕстьРежим(ОбъектДокумента, "Подписи") 
		И ОбъектДокумента.МетаИнформация.ЕстьПодпись Тогда
		ДействияПользователя = ПолучитьЗначение(ТочкаНачала, "AcroForm");
		ИзвлечьПодписиДокумента(ОбъектДокумента, ПолучитьЗначение(ДействияПользователя, "Fields"));
		ОтразитьСостояниеЗамера(ОбъектДокумента, "Извлечение ЭП", ТекущийОтсчет);
	КонецЕсли;
	
КонецПроцедуры

Процедура РежимПарсингаСканы(ОбъектДокумента, ТекущийОтсчет)
	
	Если НЕ ЕстьРежим(ОбъектДокумента, "Сканы") Тогда
		Возврат;
	КонецЕсли;
	
	ЭтоСкан = ОбъектДокумента.Страницы.Количество() > 0;
	
	Для Каждого СтрокаМассива Из ОбъектДокумента.Страницы Цикл
		ТекущийУзел = ПолучитьОбъектПоСсылке(ОбъектДокумента, СтрокаМассива); 
		ТипУзла = ПолучитьЗначение(ТекущийУзел.Описание, "Type", "");
		
		Если ТипУзла = "Pages" И ОбъектДокумента.УскоритьПолучениеСтраниц Тогда
			ВыборкаДереваСтраниц(ОбъектДокумента, СтрокаМассива);
			Продолжить;
		ИначеЕсли ТипУзла <> "Page" Тогда
			Продолжить;
		КонецЕсли;
		
		Ресурсы = ПолучитьЗначение(ТекущийУзел.Описание, "Resources");
		Содержимое = ПолучитьЗначение(ТекущийУзел.Описание, "Contents");
		Если ТипЗнч(Содержимое) = Тип("Массив") Тогда // Массив ссылок
			Содержимое = ПолучитьОбъектПоСсылке(ОбъектДокумента, Содержимое[0]);
		КонецЕсли;
		Если ПолучитьЗначение(Содержимое, "ТипОбъекта") = "Ссылка" Тогда // Ссылка
			Содержимое = ПолучитьОбъектПоСсылке(ОбъектДокумента, Содержимое);
		КонецЕсли;
		Если ПолучитьЗначение(Ресурсы, "ТипОбъекта") = "Ссылка" Тогда // Ссылка
			Ресурсы = ПолучитьОбъектПоСсылке(ОбъектДокумента, Ресурсы).Описание;
		КонецЕсли;

		УстановкиДокумента = ПолучитьЗначение(Ресурсы, "ProcSet", Новый Массив);
		КартинкиСтраницы = ПолучитьЗначение(Ресурсы, "XObject");
		ГрафСостоянияСтраницы = ПолучитьЗначение(Ресурсы, "ExtGState");
		КоличествоРазделов = 2 + ?(ГрафСостоянияСтраницы <> Неопределено, 1, 0);
			
		Если Ресурсы = Неопределено ИЛИ Содержимое = Неопределено ИЛИ Ресурсы.Количество() <> КоличествоРазделов Тогда
			ЭтоСкан = Ложь;
		Иначе
			Если ТипЗнч(КартинкиСтраницы) = Тип("Структура") Тогда // Ссылка
				КартинкиСтраницы = ПолучитьОбъектПоСсылке(ОбъектДокумента, КартинкиСтраницы);
			КонецЕсли;
			
			КартинкиСтраницы = ПолучитьЗначение(КартинкиСтраницы, "Описание", КартинкиСтраницы, Ложь);
			Если КартинкиСтраницы = Неопределено или КартинкиСтраницы.Количество() <> 1 Тогда
				ЭтоСкан = Ложь;
			КонецЕсли;
			
			Если ЭтоСкан Тогда
				Для каждого СтрокаКлюча Из КартинкиСтраницы Цикл
					ТекущаяКартинка = ПолучитьОбъектПоСсылке(ОбъектДокумента, СтрокаКлюча.Значение);
					ЭтоСкан = ЭтоСкан И ТекущаяКартинка <> Неопределено И ПолучитьЗначение(ТекущаяКартинка.Описание, "Subtype") = "Image";
				КонецЦикла;
			КонецЕсли;
			
		КонецЕсли;
		
		Если НЕ ЭтоСкан Тогда
			Прервать;
		КонецЕсли;
		
	КонецЦикла;
	
	ОбъектДокумента.Метаинформация.СканированноеИзображение = ЭтоСкан;
	ОтразитьСостояниеЗамера(ОбъектДокумента, "Проверка только на сканы", ТекущийОтсчет);
	
КонецПроцедуры

#КонецОбласти

#Область Сервисные

// Дополнительная проверка текста на нечитаемые символы.
// Актуально для клиент-серверных переходов.
//
// Возвращаемое значение:
//	Строка
//
Функция ПроверитьТекстНаСимволы(Содержимое)
	
	Результат = Содержимое;
	Позиция = НайтиНедопустимыеСимволыXML(Результат);
	
	Пока Позиция > 0 Цикл
		Результат = Лев(Результат, Позиция - 1) + Сред(Результат, Позиция + 1);
		Позиция = НайтиНедопустимыеСимволыXML(Результат);
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

// Формирует буфер двоичных данных из целого числа.
//
// Возвращаемое значение:
//	БуферДвоичныхДанных
//
Функция ДвоичноеПредставлениеЧисла(НовоеЗначение)
	
	Результат = Новый БуферДвоичныхДанных(1);
	Результат.Установить(0, НовоеЗначение);
	
	Возврат Результат;
	
КонецФункции

// Получает двоичные данные из целого числа.
//
// Возвращаемое значение:
//  ДвоичныеДанные
//
Функция ПеревестиЧислоВДвоичныеДанные(Значение, ШиринаВБайтах)
	
	Буфер = Новый БуферДвоичныхДанных(ШиринаВБайтах);
	Если ШиринаВБайтах = 2 Тогда
		Буфер.ЗаписатьЦелое16(0, Значение);
	ИначеЕсли ШиринаВБайтах = 4 Тогда
		Буфер.ЗаписатьЦелое32(0, Значение);
	ИначеЕсли ШиринаВБайтах = 8 Тогда
		Буфер.ЗаписатьЦелое64(0, Значение);
	КонецЕсли;
	
	Возврат ПолучитьДвоичныеДанныеИзБуфераДвоичныхДанных(Буфер);
	
КонецФункции

// Целое число раскладываем в набор символов.
//
// Возвращаемое значение:
//  Строка
//
Функция РазложитьЧислоВБайты(Знач ТекущееЧисло, Разрядов = 4)
	
	Результат = "";
	
	Пока ТекущееЧисло > 0 Цикл
		ТекущийКод = ТекущееЧисло % 256;
		ТекущееЧисло = Цел(ТекущееЧисло / 256);
		Результат = Символ(ТекущийКод) + Результат;
	КонецЦикла;
	
	Возврат Сред(Результат, 1, Разрядов);
	
КонецФункции

// Проверяет переданную строку на соответствие формату числа.
//
// Возвращаемое значение:
//	Булево
//
Функция ЭтоЧисло(ТекущееЗначение, ТолькоЦелое = Ложь, ТолькоПоложительное = Ложь)
	
	Результат = Ложь;
	
	Если НЕ ЗначениеЗаполнено(ТекущееЗначение) Тогда
		Возврат Результат;
	КонецЕсли;
	
	СтрокаБезНулей = СтрЗаменить(ТекущееЗначение, "0", "");
	Если ПустаяСтрока(СтрокаБезНулей) ИЛИ СтрокаБезНулей = "-" ИЛИ СтрокаБезНулей = "-." ИЛИ СтрокаБезНулей = "." Тогда
		Возврат Истина;
	КонецЕсли;
	
	ТипЧисло  = Новый ОписаниеТипов("Число");
	НовоеЧисло = ТипЧисло.ПривестиЗначение(ТекущееЗначение);
	
	Результат = НовоеЧисло <> 0;
	Результат = Результат И (НЕ ТолькоПоложительное ИЛИ НовоеЧисло > 0);
	Результат = Результат И (НЕ ТолькоЦелое ИЛИ Цел(НовоеЧисло) = НовоеЧисло);
	
	Возврат Результат;
	
КонецФункции

// Формирует строку из восьмиричного представления.
// Применяется при экранировании.
//
// Возвращаемое значение:
//	Строка
//
Функция ПолучитьСимволПоВосьмеричномуКоду(Знач ТекущееЗначение, ВзятьСимволы = Неопределено)
	
	Результат = 0;
	
	Если ВзятьСимволы <> Неопределено Тогда
		ТекущееЗначение = Сред(ТекущееЗначение, 1, ВзятьСимволы);
	КонецЕсли;
	ТекущийРазряд = 1;
		
	Остаток = Число(ТекущееЗначение);
	Пока Остаток > 0 Цикл Результат = Результат + ТекущийРазряд * (Остаток % 10); ТекущийРазряд = ТекущийРазряд * 8; Остаток = Цел(Остаток / 10); КонецЦикла; // все ради скорости
	
	Возврат Символ(Результат);
	
КонецФункции

// Формирует строку из шестьнадцетиричного представления.
// Применяется при угловых строках.
//
// Возвращаемое значение:
//	Строка
//
Функция ПолучитьСтрокуИзHEX(Кодировка, Знач ПредставлениеСтроки)
	
	Если СтрДлина(ПредставлениеСтроки) % 2 = 1 Тогда
		ПредставлениеСтроки = ПредставлениеСтроки + "0";
	КонецЕсли;
	
	ДвоичныйМассив = ПолучитьБуферДвоичныхДанныхИзHexСтроки(ПредставлениеСтроки);
	Результат = ПолучитьСтрокуИзБуфераДвоичныхДанных(ДвоичныйМассив, Кодировка);
	
	Возврат Результат;
	
КонецФункции

// Формирует число из шестьнадцетиричного представления.
// Применяется при обработке таблиц символов.
//
// Возвращаемое значение:
//	Строка
//
Функция ПолучитьЧислоИзHEX(ПредставлениеСтроки)
	
	ДвоичныйМассив = ПолучитьБуферДвоичныхДанныхИзHexСтроки(ПредставлениеСтроки);
	
	Результат = ПолучитьЧислоИзБуфера(ДвоичныйМассив, ПорядокБайтов.BigEndian);
	
	Возврат Результат;
	
КонецФункции

// Формирует число из массива байтов.
// Максимальное число для 1С - 8 байт.
//
// Возвращаемое значение:
//	Строка
//
Функция ПолучитьЧислоИзБуфера(ДвоичныйМассив, ПорядокЧтения = Неопределено)
	
	Результат = 0;
	
	Размер = ДвоичныйМассив.Размер;
	
	Если Размер = 1 Тогда
		Результат = ДвоичныйМассив[0];
		
	ИначеЕсли Размер = 2 Тогда
		Результат = ДвоичныйМассив.ПрочитатьЦелое16(0, ПорядокЧтения);
		
	ИначеЕсли Размер = 4 Тогда
		Результат = ДвоичныйМассив.ПрочитатьЦелое32(0, ПорядокЧтения);
		
	ИначеЕсли Размер = 8 Тогда
		Результат = ДвоичныйМассив.ПрочитатьЦелое64(0, ПорядокЧтения);
		
	ИначеЕсли ПорядокЧтения = ПорядокБайтов.LittleEndian Тогда
		ТекущийРазряд = 1;
		Для Счетчик = 0 По Размер - 1 Цикл
			Результат = Результат + ДвоичныйМассив[Счетчик] * ТекущийРазряд;
			ТекущийРазряд = ТекущийРазряд * 256;
		КонецЦикла;
		
	Иначе
		ТекущийРазряд = 1;
		Для Счетчик = 0 По Размер - 1 Цикл
			Результат = Результат + ДвоичныйМассив[Размер - Счетчик - 1] * ТекущийРазряд;
			ТекущийРазряд = ТекущийРазряд * 256;
		КонецЦикла;
		
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Универсальная функция для получения значения из структуры или соответствия по его имени.
//
// Возвращаемое значение:
//  Произвольное
//
Функция ПолучитьЗначение(ТекущийОбъект, ИмяЗначения, ЗначениеПоУмолчанию = Неопределено, ПроверятьТип = Истина)
	
	Результат = Неопределено;
	
	Если (ТипЗнч(ТекущийОбъект) = Тип("Структура")
		И ТекущийОбъект.Свойство(ИмяЗначения))
		ИЛИ ТипЗнч(ТекущийОбъект) = Тип("Соответствие") Тогда
		Результат = ТекущийОбъект[ИмяЗначения];
	КонецЕсли;
	
	Если Результат = Неопределено Тогда
		Результат = ЗначениеПоУмолчанию;
	КонецЕсли;
	
	Если ЗначениеПоУмолчанию <> Неопределено И ПроверятьТип Тогда
		ТекущийТип = Новый Массив;
		ТекущийТип.Добавить(ТипЗнч(ЗначениеПоУмолчанию));
 		ТекущийТип = Новый ОписаниеТипов(ТекущийТип);
		Результат = ТекущийТип.ПривестиЗначение(Результат);
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Служебная: формирует строку с ошибкой и вывода ее, в случае необходимости
//
Процедура ВывестиПротокол(ОбъектДокумента, ТекущаяОшибка)
	
	ОбъектДокумента.ТекстОшибки = ПодробноеПредставлениеОшибки(ТекущаяОшибка);
	Если ОбъектДокумента.СообщатьОшибки Тогда
		Сообщить(ОбъектДокумента.ТекстОшибки);
	КонецЕсли;
	
КонецПроцедуры

Функция СтрРазделитьТипизировать(Знач ТекущаяСтрока, Разделитель = ",", ТипЭлементов = "")
	
	Результат = Новый Массив;
	НовыйМассив = СтрРазделить(ТекущаяСтрока, Разделитель, Ложь);
	
	Для Счетчик = 0 По НовыйМассив.ВГраница() Цикл
		ТекЭлемент = НовыйМассив[Счетчик];
		Если ТипЭлементов = "Число" И ЭтоЧисло(ТекЭлемент) Тогда
			ТекЭлемент = Число(ТекЭлемент);
		КонецЕсли;
		Результат.Добавить(ТекЭлемент);
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

#КонецОбласти

#Область ПолучениеДатыНомераСрока

Функция ПодстрокиНайдены(Знач ТекстТребования, НачальнаяПодстрока, КонечнаяПодстрока)
	
	Позиция = СтрНайти(ТекстТребования, НачальнаяПодстрока);
	Если Позиция > 0 Тогда
		Позиция = СтрНайти(ТекстТребования, КонечнаяПодстрока, ,Позиция + СтрДлина(НачальнаяПодстрока));
	КонецЕсли;
	
	Возврат Позиция > 0;
	
КонецФункции

Процедура ПроверитьИДобавитьКандидата(Кандидаты, КандидатВНомер, НачальнаяПодстрока, КонечнаяПодстрока)
	
	СуммаПодстрок   = СтрДлина(НачальнаяПодстрока) + СтрДлина(КонечнаяПодстрока);
	МаксДлинаНомера = 20;
	
	Если СтрДлина(КандидатВНомер) < СуммаПодстрок + МаксДлинаНомера Тогда
	
		Шаблон   = НачальнаяПодстрока + "\s?.{1,20}\s?" + КонечнаяПодстрока; 
		Подходит = ПроверитьСтрокуНаШаблон(КандидатВНомер, Шаблон);
		
		Если Подходит Тогда
			
			Номер = КандидатВНомер;
			Номер = СтрЗаменить(Номер, НачальнаяПодстрока, "");
			Номер = СтрЗаменить(Номер, КонечнаяПодстрока, "");
			Номер = СокрЛП(Номер);
			
			Если СтрДлина(Номер) > 2 Тогда
				Кандидаты.Добавить(Номер);
			КонецЕсли;
			
		КонецЕсли;
	КонецЕсли;
	
КонецПроцедуры

Процедура ИзвлечьНомерМеждуПодстрок(Кандидаты, Знач ТекстТребования, Знач НачальнаяПодстрока, Знач КонечнаяПодстрока)
	
	ТекстТребования    = НРег(ТекстТребования);
	НачальнаяПодстрока = НРег(НачальнаяПодстрока);
	КонечнаяПодстрока  = НРег(КонечнаяПодстрока);
	
	ПозицияНачальнойПодстроки = 1;
	Пока ПозицияНачальнойПодстроки > 0 Цикл
		
		ПозицияНачальнойПодстроки = СтрНайти(ТекстТребования, НачальнаяПодстрока, , ПозицияНачальнойПодстроки);
		
		Если ПозицияНачальнойПодстроки = 0 Тогда
			Продолжить;
		КонецЕсли;
		
		ПозицияКонечнойПодстроки = СтрНайти(ТекстТребования, КонечнаяПодстрока, , ПозицияНачальнойПодстроки + СтрДлина(НачальнаяПодстрока));
		Если ПозицияКонечнойПодстроки > 0 Тогда
			
			КандидатВНомер = Сред(ТекстТребования, ПозицияНачальнойПодстроки, ПозицияКонечнойПодстроки - ПозицияНачальнойПодстроки + СтрДлина(КонечнаяПодстрока) + 1);
			
			ПроверитьИДобавитьКандидата(
				Кандидаты, 
				СокрЛП(КандидатВНомер), 
				НачальнаяПодстрока, 
				КонечнаяПодстрока);
				
		Иначе
			Прервать;
		КонецЕсли;
		
		ПозицияНачальнойПодстроки = ПозицияКонечнойПодстроки + СтрДлина(КонечнаяПодстрока);
		
	КонецЦикла;
	
КонецПроцедуры

Функция ГлавныйКандидатВНомер(Кандидаты)
	
	ГлавныйКандидат = ГлавныйКандидатПоНаличиюСимволаНомера(Кандидаты);
	
	Если Кандидаты.Количество() > 0 И ГлавныйКандидат = "" Тогда
		ГлавныйКандидат = ГлавныйКандидатИзОставшегося(Кандидаты);
	КонецЕсли;
	
	Возврат ГлавныйКандидат;
	
КонецФункции

Функция ГлавныйКандидатПоНаличиюСимволаНомера(Кандидаты)
	
	ГлавныйКандидат = "";
	Для каждого Кандидат Из Кандидаты Цикл
		
		ЕстьСимволНомера = ЕстьСимволНомера(Кандидат);
		КандидатБезЛишнихСимволов = НомерБезЛишнихСимволов(Кандидат);
		ДлинаЧистогоНомера = СтрДлина(КандидатБезЛишнихСимволов);
		
		Если ЕстьСимволНомера И ДлинаЧистогоНомера > 2 Тогда
			ГлавныйКандидат = КандидатБезЛишнихСимволов;
			Прервать;
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат ГлавныйКандидат;
	
КонецФункции

Функция ГлавныйКандидатИзОставшегося(Кандидаты)
	
	ГлавныйКандидат = "";
	Для каждого Кандидат Из Кандидаты Цикл
	
		КандидатБезЛишнихСимволов = НомерБезЛишнихСимволов(Кандидат);
		ДлинаЧистогоНомера = СтрДлина(КандидатБезЛишнихСимволов);
		
		Если ДлинаЧистогоНомера > 2 Тогда
			ГлавныйКандидат = КандидатБезЛишнихСимволов;
			Прервать;
		КонецЕсли;
	
	КонецЦикла;
	
	Возврат ГлавныйКандидат;
	
КонецФункции

Функция ЕстьСимволНомера(Номер)
	
	Возврат СтрНайти(Номер, "#") > 0 
		ИЛИ СтрНайти(Номер, "№") > 0 
		ИЛИ СтрНайти(Номер, "N") > 0;
	
КонецФункции

Функция НомерБезЛишнихСимволов(Знач Номер)
	
	// Для текста 8 августа 2016 г. № 09-12/23233 Требование
	// Номер получается "г. № 09-12/23233", а нужен "09-12/23233"
	Номер = СтрЗаменить(Номер, "г.", "");
	
	Номер = СтрЗаменить(Номер, "%", "");
	Номер = СтрЗаменить(Номер, "#", "");
	Номер = СтрЗаменить(Номер, "№", "");
	Номер = СтрЗаменить(Номер, "N", "");
	Номер = СтрЗаменить(Номер, " ", "");
	Номер = СокрЛП(Номер);

	Возврат Номер;
	
КонецФункции

Функция ТаблицаПодстрокПоиска()
	
	ПодстрокиПоиска = Новый ТаблицаЗначений;
	ПодстрокиПоиска.Колонки.Добавить("НачальнаяПодстрока");
	ПодстрокиПоиска.Колонки.Добавить("КонечнаяПодстрока");
	
	Для каждого Перечисление Из Перечисления.ВидыНалоговыхДокументов Цикл
		
		Подстроки = СтрРазделить(Нрег(Строка(Перечисление)), " ");
		
		Отбор = Новый Структура();
		Отбор.Вставить("НачальнаяПодстрока", Подстроки[0]);
		Если Подстроки.Количество() > 2 Тогда
			Отбор.Вставить("КонечнаяПодстрока", Подстроки[1] + " " + Подстроки[2]);
		ИначеЕсли Подстроки.Количество() = 2 Тогда
			Отбор.Вставить("КонечнаяПодстрока", Подстроки[1]);
		КонецЕсли;
		
		НайденыСтроки = ПодстрокиПоиска.НайтиСтроки(Отбор).Количество() <> 0;
			
		Если НЕ НайденыСтроки Тогда
			НоваяСтрока = ПодстрокиПоиска.Добавить();
			ЗаполнитьЗначенияСвойств(НоваяСтрока, Отбор);
		КонецЕсли;
	КонецЦикла;
	
	Возврат ПодстрокиПоиска;
	
КонецФункции

Функция ЗаменитьДвойныеПробелы(Знач ТекстТребования)
	
	Пока Истина Цикл
		Если СтрНайти(ТекстТребования, "  ") > 0 Тогда
			ТекстТребования = СтрЗаменить(ТекстТребования, "  ", " ");
		Иначе
			Прервать;
		КонецЕсли;
	КонецЦикла;
	
	Возврат ТекстТребования;
	
КонецФункции

Функция НомерТребования(Знач ТекстТребования, ДатаТребования) Экспорт
	
	ТекстТребования = ТекстТребованияДляИзвлеченияНомера(ТекстТребования);
	ПодстрокиПоиска = ТаблицаПодстрокПоиска();
	Кандидаты       = Новый Массив;
	ДатаТребованияСтрокой = СокрЛП(Формат(ДатаТребования, "ДФ=dd.MM.yyyy"));
	
	// Преобразовываем 02.01.2020 в 2.01.2020
	Если Лев(ДатаТребованияСтрокой, 1) = "0" Тогда
		ДатаТребованияСтрокой = Сред(ДатаТребованияСтрокой, 2);
	КонецЕсли;
	
	Для каждого ПодстрокаПоиска Из ПодстрокиПоиска Цикл
		
		СтрНачальная = ПодстрокаПоиска.НачальнаяПодстрока;
		СтрКонечная  = ПодстрокаПоиска.КонечнаяПодстрока;
		
		ПодстрокиНайдены = ПодстрокиНайдены(
			ТекстТребования, 
			СтрНачальная, 
			СтрКонечная);
			
		Если НЕ ПодстрокиНайдены Тогда
			Продолжить;
		КонецЕсли;
		
		// Для случая вида ТРЕБОВАНИЕ № 51254 об уплате налога, сбора, пени, штрафа, процентов
		ИзвлечьНомерМеждуПодстрок(Кандидаты, ТекстТребования, СтрНачальная, СтрКонечная);
		// Для случая вида ТРЕБОВАНИЕ об уплате налога, сбора, пени, штрафа, процентов № 51254 от 12.01.2020
		Позиция = СтрНайти(ТекстТребования, СтрКонечная);
		Подстрока = Сред(ТекстТребования, Позиция);
		Если ЗначениеЗаполнено(ДатаТребованияСтрокой) Тогда
			ИзвлечьНомерМеждуПодстрок(Кандидаты, Подстрока, "№", ДатаТребованияСтрокой);
			// Для случая вида 12.01.2020 № 51254 ТРЕБОВАНИЕ об уплате налога, сбора, пени, штрафа, процентов
			ИзвлечьНомерМеждуПодстрок(Кандидаты, ТекстТребования, ДатаТребованияСтрокой, СтрНачальная);
			// Для случая вида 12.01.2020 № 51254 На _____№_______ ТРЕБОВАНИЕ об уплате налога, сбора, пени, штрафа, процентов
			ИзвлечьНомерМеждуПодстрок(Кандидаты, ТекстТребования, ДатаТребованияСтрокой, НСтр("ru = 'На'"));
			Если Кандидаты.Количество() = 0 Тогда
				ИзвлечьНомерМеждуПодстрок(Кандидаты, Подстрока, "№", "на");	
			КонецЕсли;
		КонецЕсли;
		
	КонецЦикла;
		
	ГлавныйКандидат = ГлавныйКандидатВНомер(Кандидаты);
	
	Возврат ГлавныйКандидат;
	
КонецФункции

Функция ТекстТребованияДляИзвлеченияНомера(Знач ТекстТребования);
	
	ТекстТребования = СтрЗаменить(ТекстТребования, Символы.ПС, " ");
	ТекстТребования = ЗаменитьДвойныеПробелы(ТекстТребования); 
	ТекстТребования = НРег(ТекстТребования);
	ТекстТребования = ЗаменитьМесяцНаЦифры(ТекстТребования);
	
	Возврат ТекстТребования;
	
КонецФункции

Функция ПроверитьСтрокуНаШаблон(Строка, Шаблон)
	
	Чтение = Новый ЧтениеXML;
	Чтение.УстановитьСтроку(
		"<Model xmlns=""http://v8.1c.ru/8.1/xdto"" xmlns:xs=""http://www.w3.org/2001/XMLSchema"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xsi:type=""Model"">
		|<package targetNamespace=""sample-my-package"">
		|<valueType name=""testtypes"" base=""xs:string"">
		|<pattern>" + Шаблон + "</pattern>
		|</valueType>
		|<objectType name=""TestObj"">
		|<property xmlns:d4p1=""sample-my-package"" name=""TestItem"" type=""d4p1:testtypes""/>
		|</objectType>
		|</package>
		|</Model>");
	
	Модель = ФабрикаXDTO.ПрочитатьXML(Чтение);
	МояФабрикаXDTO = Новый ФабрикаXDTO(Модель);
	Пакет = МояФабрикаXDTO.Пакеты.Получить("sample-my-package");
	Тест = МояФабрикаXDTO.Создать(Пакет.Получить("TestObj"));
	
	Попытка
		Тест.TestItem = Строка;
		Возврат Истина
	Исключение
		Возврат Ложь
	КонецПопытки;
	
КонецФункции

Функция КоличествоДнейНаОтвет(Знач ТекстТребования)
	
	Дней = 0; 
	
	ТекстТребования = ТекстТребованияДляИзвлеченияНомера(ТекстТребования);
	
	Варианты = Новый Массив;
	Варианты.Добавить(Новый Структура("Начало, Конец", "в течение", "дней"));
	
	Начало = 0;
	Конец = 0;
	Для Каждого Вариант Из Варианты Цикл 
		Начало = СтрНайти(ТекстТребования, Вариант.Начало);
		Если Начало > 0 Тогда
			Начало = Начало + СтрДлина(Вариант.Начало); 
			Конец =  СтрНайти(ТекстТребования, Вариант.Конец, , Начало + 1);
		КонецЕсли;
		Если Начало > 0 И Конец > 0 Тогда
			Прервать;
		КонецЕсли;
	КонецЦикла;
	
	Если Начало > 0 И Конец > 0 Тогда
		
		КлючиПоиска = Новый Соответствие;
		КлючиПоиска.Вставить("5", 5);
		КлючиПоиска.Вставить("10", 10);
		КлючиПоиска.Вставить("20", 20);
		КлючиПоиска.Вставить("30", 30);
		КлючиПоиска.Вставить("пяти", 5);
		КлючиПоиска.Вставить("десяти", 10);
		КлючиПоиска.Вставить("двадцати", 20);
		КлючиПоиска.Вставить("тридцати", 30);
		
		Начало = Начало;
		Длина  = Конец - Начало;
		
		Подстрока = СокрЛП(Сред(ТекстТребования, Начало, Длина));
		
		Для Каждого СтрокаКлюча Из КлючиПоиска Цикл 
			Если СтрНайти(Подстрока, СтрокаКлюча.Ключ) > 0 Тогда
				Дней = СтрокаКлюча.Значение;
				Прервать;
			КонецЕсли;
		КонецЦикла;
		
	КонецЕсли;
	
	Возврат Дней;

КонецФункции

#Область ПолучениеДаты

Функция ЗаменитьМесяцНаЦифры(Знач Строка)
	
	// Заменяю дату вида 12 января 2019 на 12.01.2019
	Для Месяц = 1 По 12 Цикл
		
		МесяцСтрокой = МесяцВродительном(НРег(Формат(Дата(1, Месяц, 1), "ДФ=MMММ")));
		МесяцЧислом  = Формат(Месяц, "ЧЦ=2; ЧВН=");
		
		Строка = СтрЗаменить(Строка, " " + МесяцСтрокой + " ", "." + МесяцЧислом + ".");
		
	КонецЦикла;
	
	Возврат Строка;
	
КонецФункции

Функция МесяцВродительном(Месяц)
	
	Если Прав(Месяц, 1) = "ь" ИЛИ Прав(Месяц, 1) = "й" Тогда
		МесяцРод = Лев(Месяц, СтрДлина(Месяц) - 1) + "я";
	Иначе
		МесяцРод = Месяц + "а";
	КонецЕсли;
	
	Возврат МесяцРод;
	
КонецФункции

Процедура ПоменятьМестамиГодИДень(Подстроки)
	
	Темп = Подстроки[0];
	Подстроки[0] = Подстроки[2];
	Подстроки[2] = Темп;
	
КонецПроцедуры

Функция ПривестиГодК4Цифрам(Подстрока)
	
	Если СтрДлина(Подстрока) = 2 Тогда
		ТекущийГодСтрокой = Формат(Год(ТекущаяДата()), "ЧГ=0");
		ПервыеДвеЦифрыГода = Лев(ТекущийГодСтрокой, 2);
		Возврат ПервыеДвеЦифрыГода + Подстрока;
	Иначе
		Возврат Подстрока;
	КонецЕсли;
	
КонецФункции

Функция ДатаИзСтрокиДляPDF(Знач Строка) Экспорт
	
	СтрокаИсходная = Строка;
	Строка = ЗаменитьМесяцНаЦифры(Строка);
	СтрокаДоЗамены = Строка;
	
	СимволЗамены = "^";
	Точка = ".";
	
	// В строке заменям все цифры на Х чтобы вместо даты получить шаблон "ХХ.ХХ.ХХХХ"
	Для Цифра = 0 По 9 Цикл
		Строка = СтрЗаменить(Строка, Цифра, СимволЗамены);
	КонецЦикла;
	
	Сч = 1;
	СчЗвезд = 0;
	
	ДатаНачалась = Ложь;
	ДатаСтрокой = "";
	Пока Сч <= СтрДлина(Строка) Цикл
		
		Символ = Сред(Строка, Сч, 1);
		СимволДоЗамены = Сред(СтрокаДоЗамены, Сч, 1);
		
		Если Символ = СимволЗамены Тогда
			ДатаНачалась = Истина;
			СчЗвезд = СчЗвезд + 1;
		КонецЕсли;
		
		Если ДатаНачалась И Символ = Точка Тогда
			СчЗвезд = 0;
		КонецЕсли;
		
		Если ДатаНачалась И (Символ = СимволЗамены ИЛИ Символ = Точка) Тогда
			ДатаСтрокой = ДатаСтрокой + СимволДоЗамены;
		КонецЕсли;
		
		Если ДатаНачалась И СчЗвезд = 4 И Символ = СимволЗамены Тогда
			Прервать;
		КонецЕсли;
		
		Сч = Сч + 1;
	
	КонецЦикла;
	
	// Чтобы из 8.08.2016 получить 2016088, чтобы можно было преобразовать к дате 
	Подстроки    = СтрРазделить(ДатаСтрокой, Точка);
	
	Если Подстроки.Количество() = 3 Тогда
		Подстроки[0] = СтроковыеФункцииКлиентСервер.ДополнитьСтроку(Подстроки[0], 2, "0", "Слева");
		Подстроки[1] = СтроковыеФункцииКлиентСервер.ДополнитьСтроку(Подстроки[1], 2, "0", "Слева");
		Подстроки[2] = ПривестиГодК4Цифрам(Подстроки[2]);
		
		ПоменятьМестамиГодИДень(Подстроки);
		ДатаСтрокой = СтрСоединить(Подстроки, "");
	Иначе
		Возврат Дата(1,1,1);
	КонецЕсли;
	
	Попытка
		Дата = Дата(ДатаСтрокой);
	Исключение
		Дата = Дата(1,1,1);
	КонецПопытки;
	
	Возврат Дата;
	
КонецФункции

#КонецОбласти

#КонецОбласти

#КонецОбласти